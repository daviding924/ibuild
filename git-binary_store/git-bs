#!/bin/bash -x
# Copyright (C) <2017>  <Ding Wei>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Change log
# 170606 Create by Ding Wei
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
export LC_CTYPE=C
export LC_ALL=C

export BS_VER=0.0.2

BS_help()
{
 echo "
git-bs/$BS_VER ()
git bs <command> [<args>]

Git BS is a system for managing and versioning binary files in
association with a Git repository.  Instead of storing the binary files
within the Git repository as blobs, Git BS stores special 'pointer
files' in the repository, while storing the actual file contents on a
Git BS server.  The contents of the binary file are downloaded
automatically when needed, for example when a Git branch containing
the binary file is checked out.

Commands
--------

* git bs env:
    Display the Git BS environment.
* git bs checkout:
    Populate working copy with real content from Git BS files
* git bs clone:
    Efficiently clone a Git BS-enabled repository
* git bs log:
    Show errors from the git-bs command.
* git bs ls:
    Show information about Git BS files in the metadata and working tree.
???* git bs pull:
    Fetch BS changes from the remote & checkout any required working tree files
???* git bs push:
    Push queued binary files to the Git BS endpoint.
???* git bs status:
    Show the status of Git BS files in the working tree.
* git bs track:
    View or add Git BS paths to Git attributes.
* git bs untrack:
    Remove Git BS paths from Git Attributes.
* git bs update
    Download git BS files from a remote to latest version
* git bs version:
    Report the version number.

Low level commands
-------------------

* git bs clean:
    Git clean filter that converts large files to pointers.
* git bs smudge:
    Git smudge filter that converts pointer in blobs to the actual content.
"
}

BS_version()
{
 echo git-bs/$BS_VER
}

BS_env()
{
 BS_version
 $(git version)
 echo "
git config git-bs.url = '$(git config --global git-bs.url)'
git config git-bs.username = '$(git config --global git-bs.username)'
git config git-bs.password = '$(git config --global git-bs.password)'
git config bs.filter.clean = '$(git config --global filter.bs.clean)'
git config bs.filter.smudge = '$(git config --global filter.bs.smudge)'
git config bs.filter.process = '$(git config --global filter.bs.process)'
git config bs.filter.required = '$(git config --global filter.bs.required)'
"
 cat $GIT_TOP/.gitattributes
 BS_clone
}

BS_CHECK_ENV()
{
 if [[ -z $GIT_TOP || ! -d $GIT_TOP/.git ]] ; then
     EXIT 1 "You need to run this command from the toplevel of the working tree."
 fi

 if [[ ! $(git config --global git-bs.url) ]] ; then
     EXIT 1 "You need define git-bs.url by 'git config --global git-bs.url LOCAL_BS_SERVER_URL'."
 else
     export BS_SERVER=$(git config --global git-bs.url)
 fi

 if [[ ! $(git config --global git-bs.username) ]] ; then
     EXIT 1 "You need define git-bs.url by 'git config --global git-bs.username LOCAL_BS_SERVER_USERNAME'."
 else
     export BS_SERVER_USERNAME=$(git config --global git-bs.username)
 fi

 if [[ ! $(git config --global git-bs.password) ]] ; then
     EXIT 1 "You need define git-bs.password by 'git config --global git-bs.password LOCAL_BS_SERVER_PASSWORD'."
 else
     export BS_SERVER_PASSWORD=$(git config --global git-bs.password)
 fi

 if [[ -z $(git config --global filter.bs.required) ]] ; then
     git config --global filter.bs.clean "git-bs clean %f"
     git config --global filter.bs.smudge "git-bs smudge %f"
     git config --global filter.bs.process "git-bs filter-process"
     git config --global filter.bs.required true
 fi

 if [[ ! $(which vbindiff) || ! $(which svn) || ! $(which rsync) ]] ; then
     EXIT 1 "Please setup vbindiff, subversion and rsync"
 fi

 export BS_SERVER_OPTION="--non-interactive --no-auth-cache --username $BS_SERVER_USERNAME --password $BS_SERVER_PASSWORD"
}

SPLIT_LINE()
{
 echo "================================ $1"
}

EXIT()
{
 rm -f /tmp/BS_TARGET_REV.$BS_SEED >/dev/null 2>&1
 popd >>/tmp/git-bs.log 2>&1
 [[ $1 != 0 ]] && SPLIT_LINE "$2"
 exit $1
}

BS_clone()
{
 if [[ $(svn ls $BS_SERVER_OPTION $BS_SERVER/$GIT_URL_MD5/metadata >/dev/null 2>&1) ]] ; then
    svn mkdir $BS_SERVER_OPTION $BS_SERVER/$GIT_URL_MD5 -q -m "auto: create $GIT_URL_MD5" >>/tmp/git-bs.log 2>&1
    svn mkdir $BS_SERVER_OPTION $BS_SERVER/$GIT_URL_MD5/metadata -q -m "auto: create metadata" >>/tmp/git-bs.log 2>&1
 fi
 export BS_METADATA_INIT_REV=$(svn log $BS_SERVER_OPTION $BS_SERVER/$GIT_URL_MD5/metadata | grep ^r | tail -n1 | awk -F' ' {'print $1'} | awk -F'r' {'print $2'})

 if [[ ! -d $GIT_TOP/.git/git-bs ]] ; then
    svn co -q -r$BS_METADATA_INIT_REV $BS_SERVER_OPTION $BS_SERVER/$GIT_URL_MD5 $GIT_TOP/.git/git-bs >>/tmp/git-bs.log 2>&1
 fi
}

BS_update()
{
 export BS_update_TARGET=$1
 export BS_update_REV=$2
 [[ ! -z $BS_update_REV ]] && export FIX_REV="-r $BS_update_REV"
 if [[ ! -d $GIT_TOP/.git/git-bs ]] ; then
    BS_clone
 fi
 svn up -q $BS_SERVER_OPTION $FIX_REV $GIT_TOP/.git/git-bs/metadata/$BS_update_TARGET
}

BS_log()
{
 [[ -f /tmp/git-bs.log ]] && cat /tmp/git-bs.log
 EIXT 0
}

BS_ls()
{
 pushd $GIT_TOP >>/tmp/git-bs.log 2>&1
 [[ ! -f $GIT_TOP/.gitattributes || ! -d $GIT_TOP/.git/git-bs ]] && EXIT 0

 for BS_TARGET_NAME in $(cat $GIT_TOP/.gitattributes | awk -F' ' {'print $1'})
 do
    export BS_METADATA_NAME=$(echo $BS_TARGET_NAME | md5sum | awk -F' ' {'print $1'})
    if [[ -f $BS_TARGET_NAME && -f $GIT_TOP/.git/git-bs/metadata/$BS_METADATA_NAME ]] ; then
        SPLIT_LINE
        md5sum $GIT_TOP/.git/git-bs/metadata/$BS_METADATA_NAME
        md5sum $BS_TARGET_NAME
    fi
 done
 EXIT 0
}

BS_checkout()
{
 BS_clone
}

BS_pull()
{
 BS_clone
 BS_checkout
}

BS_push()
{
 BS_clone
}

BS_status()
{
 BS_clone
}

BS_track()
{
 BS_clone
 export BS_track_INPUT=$1
 export BS_track_TARGET=$BS_track_INPUT
 export BS_track_URL=$(dirname $BS_track_TARGET)
 export BS_track_OBJ=$(basename $BS_track_TARGET)

 if [[ ! $(grep "^$BS_track_TARGET filter=bs" .gitattributes) ]] ; then
    echo "$BS_track_TARGET filter=bs diff=bs merge=bs -text" >>.gitattributes
 fi
 git add .gitattributes
}

BS_untrack()
{
 BS_clone
 export BS_track_INPUT=$1
 export BS_track_TARGET=$BS_track_INPUT
 export BS_track_URL=$(dirname $BS_track_TARGET)
 export BS_track_OBJ=$(basename $BS_track_TARGET)

 if [[ $(grep "^$BS_track_TARGET filter=bs" .gitattributes) ]] ; then
    grep -v "^$BS_track_TARGET filter=bs" .gitattributes >.git/.gitattributes.tmp
    cp .git/.gitattributes.tmp .gitattributes
 fi
 git add .gitattributes
}

BS_reset()
{
 rm -fr $GIT_TOP/.git/git-bs
 rm -f /tmp/git-bs.log
 BS_clone
}

BS_smudge()
{
 pushd $GIT_TOP >>/tmp/git-bs.log 2>&1
 export BS_INPUT=$1
 [[ -z $BS_INPUT || ! -f $GIT_TOP/.gitattributes || ! -d $GIT_TOP/.git/git-bs ]] && EXIT 0

 export BS_TARGET=$BS_INPUT
 export BS_TARGET_REV=$(head -n1 /tmp/BS_TARGET_REV.$BS_SEED)
 export BS_METADATA_NAME=$(echo $(dirname $BS_TARGET)/$(basename $BS_TARGET) | md5sum | awk -F' ' {'print $1'})
 BS_update $BS_METADATA_NAME
 export BS_METADATA_REV=$(svn info $GIT_TOP/.git/git-bs/metadata/$BS_METADATA_NAME | grep Rev | grep Last | awk -F': ' {'print $2'})

 if [[ $BS_METADATA_REV != $BS_TARGET_REV ]] ; then
    BS_update $BS_METADATA_NAME $BS_TARGET_REV
 fi
 if [[ $(grep $BS_TARGET $GIT_TOP/.gitattributes) && -f $GIT_TOP/.git/git-bs/metadata/$BS_METADATA_NAME ]] ; then
    cat $GIT_TOP/.git/git-bs/metadata/$BS_METADATA_NAME
 fi
 EXIT 0
}

BS_clean()
{
 pushd $GIT_TOP >>/tmp/git-bs.log 2>&1
 export BS_INPUT=$1
 [[ -z $BS_INPUT || ! -f $GIT_TOP/.gitattributes || ! -d $GIT_TOP/.git/git-bs ]] && EXIT 0

 export BS_TARGET=$BS_INPUT
 export BS_TARGET_REV=$(head -n1 /tmp/BS_TARGET_REV.$BS_SEED)
 export BS_METADATA_NAME=$(echo $(dirname $BS_TARGET)/$(basename $BS_TARGET) | md5sum | awk -F' ' {'print $1'})
 BS_update $BS_METADATA_NAME
 export BS_METADATA_REV=$(svn info $GIT_TOP/.git/git-bs/metadata/$BS_METADATA_NAME | grep Rev | grep Last | awk -F': ' {'print $2'})

 if [[ $(grep $BS_TARGET $GIT_TOP/.gitattributes) ]] ; then
    cp $BS_TARGET $GIT_TOP/.git/git-bs/metadata/$BS_METADATA_NAME >>/tmp/git-bs.log 2>&1
    svn add -q $GIT_TOP/.git/git-bs/metadata/$BS_METADATA_NAME >>/tmp/git-bs.log 2>&1
    svn ci $BS_SERVER_OPTION -q -m "auto: $BS_METADATA_NAME:$BS_TARGET" $GIT_TOP/.git/git-bs/metadata/$BS_METADATA_NAME >>/tmp/git-bs.log 2>&1
    export BS_METADATA_REV=$(svn info $GIT_TOP/.git/git-bs/metadata/$BS_METADATA_NAME | grep Rev | grep Last | awk -F': ' {'print $2'})
    echo $BS_METADATA_REV
 fi
 EXIT 0
}

export BS_ARG=$1
[[ -z $BS_ARG ]] && exit 1
export BS_TARGET=$(echo $* | sed "s/$BS_ARG//g" | awk -F' ' {'print $1'})
export BS_SEED=$RANDOM

export GIT_TOP=$(git rev-parse --show-toplevel)
export GIT_URL_MD5=$(cat $GIT_TOP/.git/config | grep 'url =' | md5sum | awk -F' ' {'print $1'})

BS_CHECK_ENV

pushd $GIT_TOP >>/tmp/git-bs.log 2>&1
case ${BS_ARG} in
    pull)
        BS_pull
    ;;
    push)
        BS_push
    ;;
    status)
        BS_status
    ;;
    track)
        BS_track "$BS_TARGET"
    ;;
    untrack)
        BS_untrack "$BS_TARGET" 
    ;;
    update)
        BS_update
    ;;
    version)
        BS_version
    ;;
    env)
        BS_env
    ;;
    chekout)
        BS_checkout
    ;;
    clone)
        BS_clone
    ;;
    reset)
        BS_reset
    ;;
    clean)
        cat >/dev/null 2>&1
        BS_clean "$BS_TARGET"
    ;;
    smudge)
        cat | head -n1 >/tmp/BS_TARGET_REV.$BS_SEED
        BS_smudge "$BS_TARGET"
    ;;
    ls)
        BS_ls
    ;;
    log)
        BS_log
    ;;
    *)
        BS_help
    ;;
esac

