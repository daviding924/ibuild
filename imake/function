#!/bin/bash
# Copyright (C) <2014,2015>  <Ding Wei>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Change log
# 150120 Create by Ding Wei
source /etc/bash.bashrc
source /etc/bash.ibuild.bashrc
export LC_CTYPE=C
export LC_ALL=C
export USER=$(whoami)
export TASK_SPACE=/run/shm
export IP=$(/sbin/ifconfig | grep 'inet addr:' | egrep -v '127.0.0.1|172.17.' | awk -F':' {'print $2'} | awk -F' ' {'print $1'} | head -n1)
export MAC=$(/sbin/ifconfig | grep HWaddr | awk -F'HWaddr ' {'print $2'} | head -n1)
export HOSTNAME=$(hostname)
export DOMAIN_NAME=$(cat /etc/resolv.conf | grep search | awk -F' ' {'print $2'})
export JOBS=$(cat /proc/cpuinfo | grep CPU | wc -l)
export TODAY=$(date +%y%m%d)
export FULL_TODAY=$(date +%s)
export TOWEEK=$(date +%yw%V)
export ITASK_PATH=$TASK_SPACE/itask/svn
export TOYEAR=$(date +%Y)
export SEED=$RANDOM
export BUILD_TIME=$(date +%y%m%d%H%M%S)
export BUILD_SEC_TIME=$(date +%s)
export DISTRIB_ID=$(grep '^DISTRIB_ID=' /etc/lsb-release | awk -F'=' {'print $2'})
export DISTRIB_RELEASE=$(grep '^DISTRIB_RELEASE=' /etc/lsb-release | awk -F'=' {'print $2'})
export GIT_SSH_VARIANT=ssh

export IBUILD_ROOT=$HOME/ibuild
    [[ -z $IBUILD_ROOT ]] && export IBUILD_ROOT=$(dirname $0 | awk -F'/ibuild' {'print $1'})'/ibuild'
if [[ ! -e $HOME/ibuild/conf/ibuild.conf ]] ; then
    echo -e "Please put ibuild in your $HOME"
    exit 0
fi
export LOCK_SPACE=/dev/shm/lock
mkdir -p $LOCK_SPACE >/dev/null 2>&1
export NETCAT=$(which nc)
    [[ -z $NETCAT ]] && export NETCAT="$IBUILD_ROOT/bin/netcat.openbsd-u14.04"

if [[ ! -z $1 && $1 != node_matching ]] ; then
    export ITASK_REV=$1
fi

[[ $1 != node_matching ]] && $NETCAT 127.0.0.1 1234
# pkill -9 nc >/dev/null 2>&1

# sudo rm -f /root/ibuild >/dev/null 2>&1
# sudo ln -sf $HOME/ibuild /root/ibuild >/dev/null 2>&1

EXPORT_IBUILD_CONF()
{
 export IBUILD_SVN_SRV=$(grep '^IBUILD_SVN_SRV=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IBUILD_SVN_SRV=' {'print $2'})
 export IBUILD_SVN_OPTION=$(grep '^IBUILD_SVN_OPTION=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IBUILD_SVN_OPTION=' {'print $2'})
 export LOC_REF_REPO_PATH=$(grep '^LOC_REF_REPO_PATH=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'LOC_REF_REPO_PATH=' {'print $2'})
 export LOC_WORKSPACE=$(grep '^LOC_WORKSPACE=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'LOC_WORKSPACE=' {'print $2'})
 export IBUILD_DOWNLOAD_SRV=$(grep '^IBUILD_DOWNLOAD_SRV=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IBUILD_DOWNLOAD_SRV=' {'print $2'})
 export ICASE_SVN_SRV=$(grep '^ICASE_SVN_SRV=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'ICASE_SVN_SRV=' {'print $2'})
    [[ -z $ICASE_SVN_SRV ]] && export ICASE_SVN_SRV=$IBUILD_SVN_SRV
 export ICHANGE_SVN_SRV=$(grep '^ICHANGE_SVN_SRV=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'ICHANGE_SVN_SRV=' {'print $2'})
    [[ -z $ICHANGE_SVN_SRV ]] && export ICHANGE_SVN_SRV=$IBUILD_SVN_SRV
 export ISPEC_SVN_SRV=$(grep '^ISPEC_SVN_SRV=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'ISPEC_SVN_SRV=' {'print $2'})
    [[ -z $ISPEC_SVN_SRV  ]] && export ISPEC_SVN_SRV=$IBUILD_SVN_SRV
 export ISTATUS_SVN_SRV=$(grep '^ISTATUS_SVN_SRV=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'ISTATUS_SVN_SRV=' {'print $2'})
    [[ -z $ISTATUS_SVN_SRV ]] && export ISTATUS_SVN_SRV=$IBUILD_SVN_SRV
 export ITASK_SVN_SRV=$(grep '^ITASK_SVN_SRV=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'ITASK_SVN_SRV=' {'print $2'})
    [[ -z $ITASK_SVN_SRV ]] && export ITASK_SVN_SRV=$IBUILD_SVN_SRV
 export IVERIFY_SVN_SRV=$(grep '^IVERIFY_SVN_SRV=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IVERIFY_SVN_SRV=' {'print $2'})
    [[ -z $IVERIFY_SVN_SRV ]] && export IVERIFY_SVN_SRV=$IBUILD_SVN_SRV
 export IVERSION_SVN_SRV=$(grep '^IVERSION_SVN_SRV=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IVERSION_SVN_SRV=' {'print $2'})
    [[ -z $IVERSION_SVN_SRV ]] && export IVERSION_SVN_SRV=$IBUILD_SVN_SRV

# mkdir -p /local/{ccache,out} >/dev/null 2>&1
 mkdir -p /local/workspace/{subv_repo,build} >/dev/null 2>&1
    [[ -z $CCACHE_DIR ]] && export CCACHE_DIR=$(grep '^CCACHE_DIR=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'CCACHE_DIR=' {'print $2'})
    [[ -z $CCACHE_UMASK ]] && export CCACHE_UMASK=$(grep '^CCACHE_UMASK=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'CCACHE_UMASK=' {'print $2'})
    [[ -z $CCACHE_BASEDIR ]] && export CCACHE_BASEDIR=$(grep '^CCACHE_BASEDIR=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'CCACHE_BASEDIR=' {'print $2'})
    [[ -z $USE_CCACHE ]] && export USE_CCACHE=$(grep '^USE_CCACHE=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'USE_CCACHE=' {'print $2'})
 export JDK6_PATH=$(grep '^JDK6_PATH=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'JDK6_PATH=' {'print $2'})
 export JDK7_PATH=$(grep '^JDK7_PATH=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'JDK7_PATH=' {'print $2'})
 export IBUILD_GRTSRV_ID_DEFAULT=$(grep '^IBUILD_GRTSRV_ID=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IBUILD_GRTSRV_ID=' {'print $2'})
 export IBUILD_ROBOT=$(grep '^IBUILD_ROBOT=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IBUILD_ROBOT=' {'print $2'})
 export REPO_CMD=$(grep '^REPO_CMD=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'REPO_CMD=' {'print $2'})
 export DIST_FS_SHARE=$(grep '^DIST_FS_SHARE=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'DIST_FS_SHARE=' {'print $2'})
}

EXPORT_IBUILD_SPEC()
{
 export ITASK_REV=$1
 if [[ ! -z $ITASK_REV ]] ; then
     svn up -q $IBUILD_SVN_OPTION $ITASK_PATH
     export IBUILD_SPEC_NAME=$(svn log -v -r $ITASK_REV $IBUILD_SVN_OPTION svn://$ITASK_SVN_SRV/itask/itask | egrep 'A |M ' | head -n1 | awk -F'tasks/' {'print $2'} | awk -F' ' {'print $1'})
     if [[ ! $(grep IBUILD_GRTSRV $ITASK_PATH/tasks/$IBUILD_SPEC_NAME) ]] ; then
         SPLIT_LINE "$ITASK_PATH/tasks/$IBUILD_SPEC_NAME is not a spec.build"
         exit 1
     fi
     if [[ -e $ITASK_PATH/tasks/$IBUILD_SPEC_NAME && ! -e $TASK_SPACE/spec.build ]] ; then
         cp $ITASK_PATH/tasks/$IBUILD_SPEC_NAME $TASK_SPACE/
         ln -sf $TASK_SPACE/$IBUILD_SPEC_NAME $TASK_SPACE/spec.build
#         echo -e "-------------------------\nStart build: \n$(date) \n$IBUILD_SPEC_NAME\n-------------------------" | sudo wall -t 3 -n >/dev/null 2>&1 
     else
         SPLIT_LINE "$ITASK_PATH/tasks/$IBUILD_SPEC_NAME is not a spec.build or $TASK_SPACE/spec.build locked"
         exit 1
     fi
 fi

 if [[ -L $TASK_SPACE/spec.build ]] ; then
    export IBUILD_SPEC=$(readlink $TASK_SPACE/spec.build)
    [[ ! -e $IBUILD_SPEC ]] && export IBUILD_SPEC=$TASK_SPACE/$IBUILD_SPEC 
 elif [[ -e $TASK_SPACE/spec.build ]] ; then
    export IBUILD_SPEC=$TASK_SPACE/spec.build
 else
    SPLIT_LINE "No spec.build in $TASK_SPACE"
    exit 1
 fi

 export EMAIL_PM=$(grep '^EMAIL_PM=' $IBUILD_SPEC | awk -F'EMAIL_PM=' {'print $2'})
 export EMAIL_REL=$(grep '^EMAIL_REL=' $IBUILD_SPEC | awk -F'EMAIL_REL=' {'print $2'})
 export EMAIL_TMP=$(grep '^EMAIL_TMP=' $IBUILD_SPEC | awk -F'EMAIL_TMP=' {'print $2'})
 export IBUILD_AUTOUT_FILES=$(grep '^IBUILD_AUTOUT_FILES=' $IBUILD_SPEC | awk -F'IBUILD_AUTOUT_FILES=' {'print $2'})
 export IBUILD_LOC_REF_REPO_PATH=$(grep '^IBUILD_LOC_REF_REPO_PATH=' $IBUILD_SPEC | awk -F'IBUILD_LOC_REF_REPO_PATH=' {'print $2'})
    [[ ! -z $IBUILD_LOC_REF_REPO_PATH ]] && export LOC_REF_REPO_PATH=$IBUILD_LOC_REF_REPO_PATH
 export IBUILD_GRTSRV_ID=$(grep '^IBUILD_GRTSRV_ID=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_ID=' {'print $2'})
    [[ -z $IBUILD_GRTSRV_ID ]] && export export IBUILD_GRTSRV_ID=$IBUILD_GRTSRV_ID_DEFAULT
 export IBUILD_GRTSRV=$(grep '^IBUILD_GRTSRV=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV=' {'print $2'})
 export IBUILD_GRTSRV_PROJECT_BRANCH=$(grep '^IBUILD_GRTSRV_PROJECT_BRANCH=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_PROJECT_BRANCH=' {'print $2'})
 export IBUILD_GRTSRV_TAG=$(grep '^IBUILD_GRTSRV_TAG=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_TAG=' {'print $2'})
 export IBUILD_GRTSRV_INIT_OPTION=$(grep '^IBUILD_GRTSRV_INIT_OPTION=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_INIT_OPTION=' {'print $2'})
 export IBUILD_GRTSRV_MANIFEST=$(grep '^IBUILD_GRTSRV_MANIFEST=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_MANIFEST=' {'print $2'})
 export IBUILD_GRTSRV_MANIFEST_BRANCH=$(grep '^IBUILD_GRTSRV_MANIFEST_BRANCH=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_MANIFEST_BRANCH=' {'print $2'})
 export BUILD_ID=$IBUILD_GRTSRV_MANIFEST_BRANCH
 export IBUILD_GRTSRV_REPO=$(grep '^IBUILD_GRTSRV_REPO=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_REPO=' {'print $2'})
 export IBUILD_GRTSRV_URL=$(grep '^IBUILD_GRTSRV_URL=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_URL=' {'print $2'})
 export IBUILD_FETCH_GRTSRV=$(grep '^IBUILD_FETCH_GRTSRV=' $IBUILD_SPEC | awk -F'IBUILD_FETCH_GRTSRV=' {'print $2'})
    [[ -z $IBUILD_FETCH_GRTSRV ]] && export IBUILD_FETCH_GRTSRV=$IBUILD_GRTSRV
 export IBUILD_MAKE_OPTION=$(grep '^IBUILD_MAKE_OPTION=' $IBUILD_SPEC | awk -F'IBUILD_MAKE_OPTION=' {'print $2'})
 export IBUILD_MAKE_TOOL=$(grep '^IBUILD_MAKE_TOOL=' $IBUILD_SPEC | awk -F'IBUILD_MAKE_TOOL=' {'print $2'})
 export IBUILD_MODE=$(grep '^IBUILD_MODE=' $IBUILD_SPEC | awk -F'IBUILD_MODE=' {'print $2'})
    [[ -z $IBUILD_MODE ]] && export IBUILD_MODE=normal
 export IBUILD_UPLOAD_URL=$(grep '^IBUILD_UPLOAD_URL=' $IBUILD_SPEC | awk -F'IBUILD_UPLOAD_URL=' {'print $2'})
 export IBUILD_TARGET_BUILD_VARIANT=$(grep '^IBUILD_TARGET_BUILD_VARIANT=' $IBUILD_SPEC | awk -F'IBUILD_TARGET_BUILD_VARIANT=' {'print $2'})
 export IBUILD_TARGET_PRODUCT=$(grep '^IBUILD_TARGET_PRODUCT=' $IBUILD_SPEC | awk -F'IBUILD_TARGET_PRODUCT=' {'print $2'})
 export IBUILD_REL_REV=$(grep '^IBUILD_REL_REV=' $IBUILD_SPEC | awk -F'IBUILD_REL_REV=' {'print $2'})
 export IBUILD_ODEX=$(grep '^IBUILD_ODEX=' $IBUILD_SPEC | awk -F'IBUILD_ODEX=' {'print $2'})
 if [[ $IBUILD_ODEX = false ]] ; then
    export DISABLE_DEXPREOPT=true
    export WITH_DEXPREOPT=false
 elif [[ $IBUILD_ODEX = true ]] ; then
    export DISABLE_DEXPREOPT=false
    export WITH_DEXPREOPT=true
 elif [[ -z $IBUILD_ODEX ]] ; then
    unset DISABLE_DEXPREOPT
    unset WITH_DEXPREOPT
 fi
 export IBUILD_AOSP_JDK=$(grep '^IBUILD_AOSP_JDK=' $IBUILD_SPEC | awk -F'IBUILD_AOSP_JDK=' {'print $2'})
 export JDK_PATH=$(ls -d $JDK6_PATH $JDK7_PATH 2>/dev/null | grep $IBUILD_AOSP_JDK)
 export IBUILD_PRIORITY=$(grep '^IBUILD_PRIORITY=' $IBUILD_SPEC | awk -F'IBUILD_PRIORITY=' {'print $2'})
 export IBUILD_NOTE=$(grep '^IBUILD_NOTE=' $IBUILD_SPEC | awk -F'IBUILD_NOTE=' {'print $2'})
 export IVERIFY=$(grep '^IVERIFY=' $IBUILD_SPEC | awk -F'IVERIFY=' {'print $2'})
 export IVERIFY_PRIORITY=$(grep '^IVERIFY_PRIORITY=' $IBUILD_SPEC | awk -F'IVERIFY_PRIORITY=' {'print $2'})
 export ITASK_ORDER=$(grep '^ITASK_ORDER=' $IBUILD_SPEC | awk -F'ITASK_ORDER=' {'print $2'} | head -n1)
     [[ -z $ITASK_ORDER && ! -z $ITASK_TMP ]] && export ITASK_ORDER=$ITASK_TMP
 export IVERSION=$(grep '^IVERSION=' $IBUILD_SPEC | awk -F'IVERSION=' {'print $2'})
 export IBUILD_SUBV_REPO=$(grep '^IBUILD_SUBV_REPO=' $IBUILD_SPEC | awk -F'IBUILD_SUBV_REPO=' {'print $2'})
 export IBUILD_ADD_STEP_1=$(grep '^IBUILD_ADD_STEP_1=' $IBUILD_SPEC | awk -F'IBUILD_ADD_STEP_1=' {'print $2'})
 export IBUILD_ADD_STEP_2=$(grep '^IBUILD_ADD_STEP_2=' $IBUILD_SPEC | awk -F'IBUILD_ADD_STEP_2=' {'print $2'})
 export GERRIT_CHANGE_NUMBER=$(grep '^GERRIT_CHANGE_NUMBER=' $IBUILD_SPEC | awk -F'GERRIT_CHANGE_NUMBER=' {'print $2'})
 export GERRIT_CHANGE_ID=$(grep '^GERRIT_CHANGE_ID=' $IBUILD_SPEC | awk -F'GERRIT_CHANGE_ID=' {'print $2'})
 export GERRIT_CHANGE_URL=$(grep '^GERRIT_CHANGE_URL=' $IBUILD_SPEC | awk -F'GERRIT_CHANGE_URL=' {'print $2'})
 export GERRIT_CHANGE_OWNER_EMAIL=$(grep '^GERRIT_CHANGE_OWNER_EMAIL=' $IBUILD_SPEC | awk -F'GERRIT_CHANGE_OWNER_EMAIL=' {'print $2'})
 export GERRIT_CHANGE_OWNER_NAME=$(grep '^GERRIT_CHANGE_OWNER_NAME=' $IBUILD_SPEC | awk -F'GERRIT_CHANGE_OWNER_NAME=' {'print $2'})
 export GERRIT_PATCHSET_NUMBER=$(grep '^GERRIT_PATCHSET_NUMBER=' $IBUILD_SPEC | awk -F'GERRIT_PATCHSET_NUMBER=' {'print $2'})
 export GERRIT_PATCHSET_REVISION=$(grep '^GERRIT_PATCHSET_REVISION=' $IBUILD_SPEC | awk -F'GERRIT_PATCHSET_REVISION=' {'print $2'})
 export GERRIT_PROJECT=$(grep '^GERRIT_PROJECT=' $IBUILD_SPEC | awk -F'GERRIT_PROJECT=' {'print $2'})
     [[ ! -z $IBUILD_GRTSRV_MANIFEST_BRANCH ]] && export IBUILD_GRTSRV_MANIFEST_BRANCH_TOP=$(echo $IBUILD_GRTSRV_MANIFEST_BRANCH | awk -F'/' {'print $1'})
 export GERRIT_REFSPEC=$(grep '^GERRIT_REFSPEC=' $IBUILD_SPEC | awk -F'GERRIT_REFSPEC=' {'print $2'})

 export SPEC_NAME=$(basename $IBUILD_SPEC)
 export AUTOUT_PATH=$LOC_WORKSPACE/autout
 export AUTOUT_UPLOAD_PATH=$LOC_WORKSPACE/upload
# [[ $(echo $SPEC_NAME | grep patch.spec.build) ]] && export PATCH_SPEC='patch.' || export PATCH_SPEC=''
 [[ $IBUILD_MODE != normal ]] && export PATCH_SPEC="$IBUILD_MODE." || export PATCH_SPEC=''
 if [[ ! -z $DIST_FS_SHARE && -e $DIST_FS_SHARE/README ]] ; then
    export AUTOUT_UPLOAD_PATH=$DIST_FS_SHARE
 fi
 export AUTOUT_NAME=$PATCH_SPEC$(echo $SPEC_NAME | awk -F'spec.build.' {'print $2'})
 export LOG_PATH=$AUTOUT_PATH/$AUTOUT_NAME/log
    mkdir -p $AUTOUT_PATH/$AUTOUT_NAME $AUTOUT_UPLOAD_PATH $LOG_PATH $AUTOUT_PATH/log >/dev/null 2>&1
    echo '#'$SPEC_NAME >$LOG_PATH/build_info.txt
    cat $TASK_SPACE/spec.build >>$LOG_PATH/build_info.txt
}

FILTER_BAD_PATCH()
{
 export BAD_PATCH_FILTER=$1
 echo $BAD_PATCH_FILTER >>$LOG_PATH/rebundle.log 2>&1
# export BAD_PATCH_PROJECT=$(grep error $LOG_PATH/bundle.log | egrep 'not found' | awk -F' ' {'print $3'})
 export NEW_IBUILD_SPEC_NAME=rebundle.spec.build.$(basename $IBUILD_SPEC | awk -F'spec.build.' {'print $2'})
 export BAD_PATCH_ENTRY=$(grep $BAD_PATCH_FILTER $IBUILD_SPEC | head -n1)
 [[ $(echo $BAD_PATCH_ENTRY | grep '|') ]] && export BAD_PATCH_ENTRY=$BAD_PATCH_FILTER
 cp $IBUILD_SPEC /tmp/$NEW_IBUILD_SPEC_NAME

 grep $BAD_PATCH_ENTRY /tmp/$NEW_IBUILD_SPEC_NAME >>$LOG_PATH/rebundle.log 2>&1
 egrep -v "$BAD_PATCH_ENTRY|^ITASK_ORDER=$" /tmp/$NEW_IBUILD_SPEC_NAME >$TASK_SPACE/tmp.spec.$SEED

 if [[ ! $(grep '^ITASK_ORDER=' $TASK_SPACE/tmp.spec.$SEED) ]] ; then
     [[ -z $ITASK_ORDER ]] && export ITASK_ORDER=$ITASK_TMP
     echo "ITASK_ORDER=$ITASK_TMP" >>$TASK_SPACE/tmp.spec.$SEED
 fi
 cp $TASK_SPACE/tmp.spec.$SEED /tmp/$NEW_IBUILD_SPEC_NAME

 rm -f /tmp/itask $TASK_SPACE/tmp.spec.$SEED

 svn export -q $IBUILD_SVN_OPTION svn://$ITASK_SVN_SRV/ispec/ispec/itask /tmp
 chmod +x /tmp/itask

 SPLIT_LINE "add new task after remove $BAD_PATCH_ENTRY"
 /tmp/itask /tmp/$NEW_IBUILD_SPEC_NAME >>$LOG_PATH/rebundle.log 2>&1
}

GIT_LOG()
{
 cd $1
 export GIT_LOG_SINCE="1,weeks"
 echo $1 >>$LOG_PATH/git_log.txt
 echo $1 >>$LOG_PATH/release_log.txt
 echo $1 >>$LOG_PATH/git_diff.txt
 git log --pretty=format:"%h %s" --graph --since=$GIT_LOG_SINCE >>$LOG_PATH/git_log.txt
 git shortlog --since=$GIT_LOG_SINCE >>$LOG_PATH/release_log.txt
 git log --pretty=format:"%h %s" --graph -p --since=$GIT_LOG_SINCE >>$LOG_PATH/git_diff.txt
 cd -
}

GET_REMOTE_NAME()
{
 [[ -z $REMOTE_NAME ]] && export REMOTE_NAME=$(cat $BUILD_PATH_TOP/.repo/manifests/*.xml | grep remote= | awk -F'="' {'print $2'} | awk -F'"' {'print $1'} | sort -u)
 if [[ ! -z $REMOTE_NAME && $(echo $GERRIT_PROJECT | egrep "^$REMOTE_NAME/") ]] ; then
    export REAL_GERRIT_PROJECT=$(echo $GERRIT_PROJECT | sed "s/$REMOTE_NAME\///g")
    export FETCH_GERRIT_PROJECT=$GERRIT_PROJECT
 elif [[ ! -z $REMOTE_NAME && ! $(echo $GERRIT_PROJECT | egrep "^$REMOTE_NAME/") ]] ; then
    export REAL_GERRIT_PROJECT=$GERRIT_PROJECT
    export FETCH_GERRIT_PROJECT=$REMOTE_NAME/$GERRIT_PROJECT
 else
    export REAL_GERRIT_PROJECT=$GERRIT_PROJECT
    export FETCH_GERRIT_PROJECT=$GERRIT_PROJECT
 fi
 echo "REMOTE_NAME=$REMOTE_NAME" >>$LOG_PATH/build_info.txt
}

TOPIC_BUILD()
{
 export Change_ID=$RANDOM
 ssh $IBUILD_GRTSRV gerrit query commit:$GERRIT_PATCHSET_REVISION >/tmp/patch_info.tmp
 export GERRIT_TOPIC=$(cat /tmp/patch_info.tmp | grep 'topic:' | awk -F': ' {'print $2'})

 if [[ -z $GERRIT_TOPIC ]] ; then
    echo "Can NOT find $GERRIT_TOPIC"
    CLEAN_EXIT 1
 else
    SPLIT_LINE "topic: $GERRIT_TOPIC"
 fi

 rm -f /tmp/topic.*.tmp

 $REPO_CMD list >/tmp/repo.list

 ssh $IBUILD_GRTSRV gerrit query --patch-sets topic:{\"$GERRIT_TOPIC\"} is:open >/tmp/topic.$TODAY.$SEED.tmp

 cat /tmp/topic.$TODAY.$SEED.tmp | while read line
 do
    [[ $(echo $line | grep '^change I') ]] && export Change_ID=$(echo $line | awk -F' ' {'print $2'})
    echo $line >>/tmp/topic.$Change_ID.tmp
 done

[[ ! -z $GERRIT_TOPIC ]] && echo "GERRIT_TOPIC=$GERRIT_TOPIC" >>$LOG_PATH/build_info.txt

for TOPIC_ID in $(ls /tmp/ | grep topic.I)
do
    GET_REMOTE_NAME
    export GERRIT_PROJECT=$(cat /tmp/$TOPIC_ID | sort -u | grep '^project: ' | awk -F': ' {'print $2'})
    GET_REMOTE_NAME
    export REAL_GERRIT_PROJECT=$(cat /tmp/$TOPIC_ID | sort -u | grep '^project: ' | sed "s/$REMOTE_NAME\///g" | awk -F': ' {'print $2'})
    export LOCAL_PROJECT_PATH=$(cat /tmp/repo.list | egrep ": $REAL_GERRIT_PROJECT$" | awk -F':' {'print $1'} | head -n1)
    export GERRIT_REFSPEC=$(cat /tmp/$TOPIC_ID | grep '^ref: ' | tail -n1 | awk -F': ' {'print $2'})

    if [[ $(echo $REAL_GERRIT_PROJECT | grep manifest) ]] ; then
        export LOCAL_PROJECT_PATH=.repo/manifests
    fi

    if [[ ! -z $LOCAL_PROJECT_PATH ]] ; then
        SPLIT_LINE "$LOCAL_PROJECT_PATH: $FETCH_GERRIT_PROJECT $GERRIT_REFSPEC"

        echo "------------------------- topic: $GERRIT_TOPIC $(echo $TOPIC_ID | awk -F'.' {'print $2'})" >>$LOG_PATH/topic.log 2>&1
        echo "cd $BUILD_PATH_TOP/$LOCAL_PROJECT_PATH" >>$LOG_PATH/topic.log 2>&1
        echo "git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC" >>$LOG_PATH/topic.log 2>&1
        echo -e "git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC \n" >>$LOG_PATH/build_info.txt

        pushd $BUILD_PATH_TOP/$LOCAL_PROJECT_PATH >>$LOG_PATH/topic.log 2>&1
        git clean -fxd
        git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC >>$LOG_PATH/topic.log 2>&1
        export STATUS_GIT=$?
        if [[ $STATUS_GIT = 0 ]] ; then
             git cherry-pick FETCH_HEAD >>$LOG_PATH/topic.log 2>&1
             export STATUS_GIT=$?
             if [[ $STATUS_GIT != 0 ]] ; then
                 SPLIT_LINE "git cherry-pick -m 1 FETCH_HEAD"
                 git cherry-pick --abort >>$LOG_PATH/topic.log 2>&1
                 git reset --hard >>$LOG_PATH/topic.log 2>&1
                 git clean -fxd >>$LOG_PATH/topic.log 2>&1
                 git cherry-pick -m 1 FETCH_HEAD >>$LOG_PATH/topic.log 2>&1
                 export STATUS_GIT=$?
             fi
             if [[ $STATUS_GIT != 0 ]] ; then
                 SPLIT_LINE "git cherry-pick -m 2 FETCH_HEAD"
                 git cherry-pick --abort >>$LOG_PATH/topic.log 2>&1
                 git reset --hard >>$LOG_PATH/topic.log 2>&1
                 git clean -fxd >>$LOG_PATH/topic.log 2>&1
                 git cherry-pick -m 2 FETCH_HEAD >>$LOG_PATH/topic.log 2>&1
                 export STATUS_GIT=$?
             fi
             echo $STATUS_GIT >>$LOG_PATH/topic.log
        fi
        popd >>$LOG_PATH/topic.log 2>&1

        SETUP_ISTATUS "topic: $FETCH_GERRIT_PROJECT $GERRIT_REFSPEC" $ITASK_REV
        LOG_STATUS $STATUS_GIT topic $LOG_PATH/topic.log
    else
        SPLIT_LINE "Can NOT find $LOCAL_PROJECT_PATH in local workspace"
        LOG_STATUS 1 topic $LOG_PATH/topic.log
    fi
 done

 rm -f /tmp/topic.*.tmp /tmp/patch_into.tmp
}

BUNDLE_BUILD()
{
 $REPO_CMD list >/tmp/repo.list
 SPLIT_LINE "bundle_build"

 grep '^BUNDLE_PATCH=' $IBUILD_SPEC | awk -F'BUNDLE_PATCH=' {'print $2'} | while read BUNDLE_PATCH_ENTRY
 do
    export EMAIL_PATCH_OWNER=$(echo $BUNDLE_PATCH_ENTRY | awk -F'|' {'print $1'})
    export GERRIT_PROJECT=$(echo $BUNDLE_PATCH_ENTRY | awk -F'|' {'print $2'} | awk -F' ' {'print $1'})
    export GERRIT_REFSPEC=$(echo $BUNDLE_PATCH_ENTRY | awk -F'|' {'print $2'} | awk -F' ' {'print $2'})
    GET_REMOTE_NAME
    export REAL_GERRIT_PROJECT=$(echo $GERRIT_PROJECT | sed "s/$REMOTE_NAME\///g")
    export LOCAL_PROJECT_PATH=$(cat /tmp/repo.list | egrep ": $REAL_GERRIT_PROJECT$" | awk -F':' {'print $1'} | head -n1)

    SPLIT_LINE "$LOCAL_PROJECT_PATH: $FETCH_GERRIT_PROJECT $GERRIT_REFSPEC"
    if [[ ! -z $LOCAL_PROJECT_PATH ]] ; then
        SPLIT_LINE "$LOCAL_PROJECT_PATH: $FETCH_GERRIT_PROJECT $GERRIT_REFSPEC"

        echo "------------------------- $EMAIL_PATCH_OWNER" >>$LOG_PATH/bundle.log 2>&1
        echo "cd $BUILD_PATH_TOP/$LOCAL_PROJECT_PATH" >>$LOG_PATH/bundle.log 2>&1
        echo "git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC" >>$LOG_PATH/bundle.log 2>&1
        echo -e "git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC \n" >>$LOG_PATH/build_info.txt

        pushd $BUILD_PATH_TOP/$LOCAL_PROJECT_PATH >>$LOG_PATH/bundle.log 2>&1
        git clean -fxd
        git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC >>$LOG_PATH/bundle.log 2>&1
        export STATUS_GIT=$?
        if [[ $STATUS_GIT = 0 ]] ; then
             git cherry-pick FETCH_HEAD >>$LOG_PATH/bundle.log 2>&1
             export STATUS_GIT=$?
             if [[ $STATUS_GIT != 0 ]] ; then
                 SPLIT_LINE "git cherry-pick -m 1 FETCH_HEAD"
                 git cherry-pick --abort >>$LOG_PATH/bundle.log 2>&1
                 git reset --hard >>$LOG_PATH/bundle.log 2>&1
                 git clean -fxd >>$LOG_PATH/bundle.log 2>&1
                 git cherry-pick -m 1 FETCH_HEAD >>$LOG_PATH/bundle.log 2>&1
                 export STATUS_GIT=$?
             fi
             if [[ $STATUS_GIT != 0 ]] ; then
                 SPLIT_LINE "git cherry-pick -m 2 FETCH_HEAD"
                 git cherry-pick --abort >>$LOG_PATH/bundle.log 2>&1
                 git reset --hard >>$LOG_PATH/bundle.log 2>&1
                 git clean -fxd >>$LOG_PATH/bundle.log 2>&1
                 git cherry-pick -m 2 FETCH_HEAD >>$LOG_PATH/bundle.log 2>&1
                 export STATUS_GIT=$?
             fi
             echo $STATUS_GIT >>$LOG_PATH/bundle.log
        fi
        popd >>$LOG_PATH/bundle.log 2>&1

        [[ $STATUS_GIT != 0 ]] && FILTER_BAD_PATCH $GERRIT_REFSPEC

        SETUP_ISTATUS "bundle: $FETCH_GERRIT_PROJECT $GERRIT_REFSPEC" $ITASK_REV
        LOG_STATUS $STATUS_GIT bundle $LOG_PATH/bundle.log
   else
        FILTER_BAD_PATCH $GERRIT_REFSPEC
        SPLIT_LINE "Can NOT find $LOCAL_PROJECT_PATH in local workspace"
        LOG_STATUS 1 bundle $LOG_PATH/bundle.log
   fi
 done

 grep '^git fetch' $IBUILD_SPEC | awk -F'&&' {'print $1'} | while read BUNDLE_PATCH_ENTRY
 do
    if [[ $(echo $BUNDLE_PATCH_ENTRY | grep @) ]] ; then
        export BUNDLE_USER_ID=$(echo $BUNDLE_PATCH_ENTRY | awk -F'@' {'print $1'} | awk -F'//' {'print $2'})
        export BUNDLE_PATCH_ENTRY=$(echo $BUNDLE_PATCH_ENTRY | sed "s/$BUNDLE_USER_ID@//g")
    fi
    if [[ $(echo $BUNDLE_PATCH_ENTRY | sed 's/ssh://g' | grep ":") ]] ; then
        export BUNDLE_PATCH_GRTSRV_PORT=$(echo $BUNDLE_PATCH_ENTRY | awk -F':' {'print $3'} | awk -F'/' {'print $1'})
        export BUNDLE_PATCH_ENTRY=$(echo $BUNDLE_PATCH_ENTRY | sed "s/:$IBUILD_FETCH_GRTSRV_PORT//g")
    fi
    export BUNDLE_PATCH_GRTSRV=$(echo $BUNDLE_PATCH_ENTRY | awk -F'//' {'print $2'} | awk -F'/' {'print $1'})

    export GERRIT_PROJECT=$(echo $BUNDLE_PATCH_ENTRY | awk -F'$BUNDLE_PATCH_GRTSRV/' {'print $2'} | awk -F' ' {'print $1'})
    export GERRIT_REFSPEC=$(echo $BUNDLE_PATCH_ENTRY | awk -F'$BUNDLE_PATCH_GRTSRV/' {'print $2'} | awk -F' ' {'print $2'})
    GET_REMOTE_NAME
    export REAL_GERRIT_PROJECT=$(echo $GERRIT_PROJECT | sed "s/$REMOTE_NAME\///g")
    export LOCAL_PROJECT_PATH=$(cat /tmp/repo.list | egrep ": $REAL_GERRIT_PROJECT$" | awk -F':' {'print $1'} | head -n1)

    SPLIT_LINE "bundle: $REAL_GERRIT_PROJECT $GERRIT_REFSPEC"
    if [[ ! -z $LOCAL_PROJECT_PATH ]] ; then
        SPLIT_LINE "bundle: git fetch $GERRIT_REFSPEC in $LOCAL_PROJECT_PATH"

        echo "------------------------- bundle: " >>$LOG_PATH/bundle.log 2>&1
        echo "cd $BUILD_PATH_TOP/$LOCAL_PROJECT_PATH" >>$LOG_PATH/bundle.log 2>&1
        echo "git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC" >>$LOG_PATH/bundle.log 2>&1
        echo -e "git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC \n" >>$LOG_PATH/build_info.txt

        pushd $BUILD_PATH_TOP/$LOCAL_PROJECT_PATH
        git clean -fxd
        git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC >>$LOG_PATH/bundle.log 2>&1
        export STATUS_GIT=$?
        if [[ $STATUS_GIT = 0 ]] ; then
             git cherry-pick FETCH_HEAD >>$LOG_PATH/bundle.log 2>&1
             export STATUS_GIT=$?
             if [[ $STATUS_GIT != 0 ]] ; then
                 SPLIT_LINE "git cherry-pick -m 1 FETCH_HEAD"
                 git cherry-pick --abort >>$LOG_PATH/bundle.log 2>&1
                 git reset --hard >>$LOG_PATH/bundle.log 2>&1
                 git clean -fxd >>$LOG_PATH/bundle.log 2>&1
                 git cherry-pick -m 1 FETCH_HEAD >>$LOG_PATH/bundle.log 2>&1
                 export STATUS_GIT=$?
             fi
             if [[ $STATUS_GIT != 0 ]] ; then
                 SPLIT_LINE "git cherry-pick -m 2 FETCH_HEAD"
                 git cherry-pick --abort >>$LOG_PATH/bundle.log 2>&1
                 git reset --hard >>$LOG_PATH/bundle.log 2>&1
                 git clean -fxd >>$LOG_PATH/bundle.log 2>&1
                 git cherry-pick -m 2 FETCH_HEAD >>$LOG_PATH/bundle.log 2>&1
                 export STATUS_GIT=$?
             fi
             echo $STATUS_GIT >>$LOG_PATH/bundle.log
        fi
        popd

        SETUP_ISTATUS "bundle: $FETCH_GERRIT_PROJECT $GERRIT_REFSPEC" $ITASK_REV
        LOG_STATUS $STATUS_GIT bundle $LOG_PATH/bundle.log
   else
        SPLIT_LINE "Can NOT find $LOCAL_PROJECT_PATH in local workspace"
        LOG_STATUS 1 bundle $LOG_PATH/bundle.log
   fi
 done

 [[ -e $BUILD_PATH_TOP && $(pwd) != $BUILD_PATH_TOP ]] && cd $BUILD_PATH_TOP
 EXPORT_MANIFEST $LOG_PATH/after_patch_manifest.xml
}

SPLIT_LINE()
{
 export SPLIT_WORD=''
    [[ ! -z $1 ]] && export SPLIT_WORD=" $1 "
 echo -e "\n-------------------------$SPLIT_WORD"
}

BTRFS_CLEANUP_SUBV_REPO()
{
 for SUBV_REPO_MD5 in $(ls $LOC_WORKSPACE/subv_repo | egrep -v 'info')
 do
    export SUBV_REPO_CLEAN=''
    export SUBV_REPO_TIME=$(stat -c %Z $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5)
    export SUBV_REPO_SIZE=$(du -sh $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5/.repo 2>/dev/null | grep G | awk -F'G' {'print $1'} | awk -F'.' {'print $1'})
        [[ ! -z $SUBV_REPO_SIZE && $SUBV_REPO_SIZE -ge 10 ]] && export SUBV_REPO_CLEAN=yes
    [[ $(echo $FULL_TODAY - $SUBV_REPO_TIME | bc) -ge 2600000 ]] && export SUBV_REPO_CLEAN=yes

    if [[ ! -z $SUBV_REPO_CLEAN ]] ; then
        export SEED=$RANDOM
        echo -------------------------
        echo $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5
        echo $LOC_WORKSPACE/build/bad.$SEED
        cat $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5.info
        echo -------------------------
        mv $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5 $LOC_WORKSPACE/build/bad.$SEED
        mv $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5.info $LOC_WORKSPACE/build/bad.$SEED/
    fi
 done
}

BTRFS_CLEANUP()
{
 export BTRFS_TOP=$(basename $1)

 for SUBV_REPO_MD5 in $(ls $LOC_WORKSPACE/subv_repo | egrep -v 'info|tmp')
 do
    export SUBV_REPO_CLEAN=''
    [[ ! -e $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5/Makefile ]] && export SUBV_REPO_CLEAN=yes
    if [[ ! -z $SUBV_REPO_CLEAN ]] ; then
        export SEED=$RANDOM
        echo -------------------------
        echo $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5
        echo $LOC_WORKSPACE/build/bad.$SEED
        cat $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5.info
        echo -------------------------
        mv $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5 $LOC_WORKSPACE/build/bad.$SEED
        mv $LOC_WORKSPACE/subv_repo/$SUBV_REPO_MD5.info $LOC_WORKSPACE/build/bad.$SEED/
    fi
 done

 rm -f $LOC_WORKSPACE/build/*.info >/dev/null 2>&1

 for BTRFS_SUBVOL in $(ls $LOC_WORKSPACE/build/ | egrep -v 'tmp')
 do
    mv $LOC_WORKSPACE/build/$BTRFS_SUBVOL $LOC_WORKSPACE/build/bad.$SEED.$RANDOM >/dev/null 2>&1
 done

 for BTRFS_SUBVOL in $(sudo btrfs subvolume list $LOC_WORKSPACE | egrep -v 'subv_repo|tmp' | awk -F'path ' {'print $2'} | grep $BTRFS_TOP | awk -F'build/' {'print $2'})
 do
    sleep 3
    SPLIT_LINE clean_$LOC_WORKSPACE/$BTRFS_SUBVOL
    time sudo btrfs subvolume delete $LOC_WORKSPACE/build/$BTRFS_SUBVOL >>$LOG_PATH/fs_issue.log 2>&1
    [[ $? != 0 ]] && echo "fs: "$(date) >>$LOCK_SPACE/count
 done

 if [[ $(sudo btrfs subvolume list $LOC_WORKSPACE | grep $BTRFS_TOP) ]] ; then
    sudo btrfs subvolume list $LOC_WORKSPACE | grep $BTRFS_TOP >>$LOG_PATH/fs_issue.log 2>&1
    echo "fs_issue: "$(date) >>$LOCK_SPACE/count
 fi
 rm -fr $LOC_WORKSPACE/build/bad.* >/dev/null 2>&1
}

MASK_LOG()
{
 export MASK_LOG_SRC=$1
 cat $MASK_LOG_SRC | sed "s/$IBUILD_GRTSRV_ID/*/g" >/tmp/tmp.log.$SEED
 mv /tmp/tmp.log.$SEED $MASK_LOG_SRC
}

REPO_INFO()
{
 export IBUILD_GRTSRV_PORT=$(echo $IBUILD_GRTSRV | awk -F':' {'print $2'})
    [[ -z $IBUILD_GRTSRV_PORT ]] && export IBUILD_GRTSRV_PORT=29418
 export IBUILD_GRTSRV_NAME=$(echo $IBUILD_GRTSRV | awk -F':' {'print $1'})
 ssh -p $IBUILD_GRTSRV_PORT $IBUILD_GRTSRV_NAME >$AUTOUT_PATH/log/$IBUILD_GRTSRV_NAME.log 2>&1
 MASK_LOG $AUTOUT_PATH/log/$IBUILD_GRTSRV_NAME.log
 
 export REPO_INIT_CMD=''
 [[ ! -z $IBUILD_GRTSRV_REPO ]] && export REPO_INIT_CMD=$REPO_INIT_CMD"--repo-url=$IBUILD_GRTSRV_REPO"
 [[ ! -z $IBUILD_GRTSRV_INIT_OPTION ]] && export REPO_INIT_CMD=$REPO_INIT_CMD" $IBUILD_GRTSRV_INIT_OPTION"
 [[ ! -z $LOC_REF_REPO_PATH ]] && export REPO_INIT_CMD=$REPO_INIT_CMD" --reference=$LOC_REF_REPO_PATH"
 [[ ! -z $IBUILD_GRTSRV_MANIFEST_BRANCH ]] && export REPO_INIT_CMD=$REPO_INIT_CMD" -b $IBUILD_GRTSRV_MANIFEST_BRANCH"
 [[ ! -z $IBUILD_GRTSRV_MANIFEST && $IBUILD_GRTSRV_MANIFEST != default.xml ]] && export REPO_INIT_CMD=$REPO_INIT_CMD" -m $IBUILD_GRTSRV_MANIFEST"

 echo "$REPO_CMD init -u ssh://$IBUILD_GRTSRV/$IBUILD_GRTSRV_URL $REPO_INIT_CMD" >/tmp/$USER.repo_init.tmp
 export REPO_INIT_CMD_MD5_NAME=$(cat /tmp/$USER.repo_init.tmp | md5sum | awk -F' ' {'print $1'} | cut -c1-5)
 export BTRFS_NAME=$REPO_INIT_CMD_MD5_NAME
 export BUILD_PATH_TOP=$LOC_WORKSPACE/build/ibuild
 [[ -e $BUILD_PATH_TOP && $(pwd) != $BUILD_PATH_TOP ]] && cd $BUILD_PATH_TOP
 
 if [[ ! -z $IBUILD_SUBV_REPO && -e $LOC_WORKSPACE/subv_repo/$IBUILD_SUBV_REPO ]] ; then
    export LOC_SUBV_REPO=$LOC_WORKSPACE/subv_repo/$IBUILD_SUBV_REPO
 else
    export LOC_SUBV_REPO=$LOC_WORKSPACE/subv_repo/$REPO_INIT_CMD_MD5_NAME
 fi
 [[ ! -e $LOC_SUBV_REPO ]] && SETUP_SUBV_REPO
}

SETUP_SUBV_REPO()
{
 if [[ ! -e $LOC_WORKSPACE/subv_repo/$REPO_INIT_CMD_MD5_NAME ]] ; then
    mv /tmp/$USER.repo_init.tmp $LOC_WORKSPACE/subv_repo/$REPO_INIT_CMD_MD5_NAME.info

    pushd $LOC_WORKSPACE/subv_repo/
    btrfs subvolume create $REPO_INIT_CMD_MD5_NAME >/dev/null 2>&1
    chmod 775 $LOC_WORKSPACE/subv_repo/$REPO_INIT_CMD_MD5_NAME
    popd

    cd $LOC_WORKSPACE/subv_repo/$REPO_INIT_CMD_MD5_NAME
    /bin/bash $LOC_WORKSPACE/subv_repo/$REPO_INIT_CMD_MD5_NAME.info >$LOG_PATH/init.log 2>&1
    MASK_LOG $LOG_PATH/init.log
    REPO_SYNC $LOC_WORKSPACE/subv_repo/$REPO_INIT_CMD_MD5_NAME
    cp $LOC_WORKSPACE/subv_repo/$REPO_INIT_CMD_MD5_NAME.info $LOC_WORKSPACE/subv_repo/$REPO_INIT_CMD_MD5_NAME/ >/dev/null 2>&1
 fi
}

IBUILD_ADD_STEPS()
{
 export IBUILD_ADD_STEP_CMD=$1
 SPLIT_LINE "$IBUILD_ADD_STEP_CMD"

 echo ---------- $(date) >>$LOG_PATH/ibuild_add_steps.log 2>&1
 [[ $(echo $IBUILD_ADD_STEP_CMD | egrep '^source ') ]] && export SOURCE_CMD=source || export SOURCE_CMD=''
 time $SOURCE_CMD $IBUILD_ROOT/hotfix/$(echo $IBUILD_ADD_STEP_CMD | awk -F'ibuild/hotfix/' {'print $2'}) >>$LOG_PATH/ibuild_add_steps.log 2>&1
 LOG_STATUS $? $IBUILD_ADD_STEP_CMD $LOG_PATH/ibuild_add_steps.log
 echo ---------- $(date) >>$LOG_PATH/ibuild_add_steps.log 2>&1
}

REPO_SYNC()
{
 if [[ ! -z $1 ]] ; then
    export REPO_WORKSPACE=$1
 else
    SPLIT_LINE no_repo_workspace
    exit 0
 fi
 if [[ ! -e $REPO_WORKSPACE ]] ; then
    SPLIT_LINE "repo_workspace_path_issue: $REPO_WORKSPACE"
    exit 0
 fi

 cd $REPO_WORKSPACE
 sudo sysctl -w net.ipv4.tcp_window_scaling=0 >/dev/null 2>&1

 export REPO_SYNC_MD5_INFO=$1.info
 export REPO_SYNC_LOG_NAME=sync-$(basename $1)
 export INDEX_LOCK=''

 pwd >>$AUTOUT_PATH/log/init.log

 if [[ ! -e $LOC_REF_REPO_PATH ]] ; then
    sudo umount /local/ref_repo >>$AUTOUT_PATH/log/init.log 2>&1
    sudo mount -a
    $IBUILD_ROOT/setup/ibuild_node_reg.sh >>$AUTOUT_PATH/log/init.log 2>&1
 fi

 if [[ -e $REPO_SYNC_MD5_INFO ]] ; then
    SPLIT_LINE repo_init
    /bin/bash $REPO_SYNC_MD5_INFO >>$AUTOUT_PATH/log/init.log 2>&1
    export REPO_INIT_STATUS=$?
    MASK_LOG $AUTOUT_PATH/log/init.log
    LOG_STATUS $REPO_INIT_STATUS repo_init $AUTOUT_PATH/log/init.log
 fi

 if [[ ! -z $IVERSION && ! -e $REPO_SYNC_MD5_INFO ]] ; then
    export BUILD_NUMBER=$IVERSION
    export REPO_SYNC_OPTION="-m manifest-r$IVERSION.xml"
    export IVER_MANIFEST_URL=$(svn log -v -r $IVERSION $IBUILD_SVN_OPTION svn://$IVERSION_SVN_SRV/iversion | egrep 'A /iversion|M /iversion' | awk -F' ' {'print $2'})
    export MANIFEST_NAME=$(basename $IVER_MANIFEST_URL | sed 's/.xml//g')

    echo $BUILD_NUMBER >$LOCK_SPACE/BUILD_NUMBER
    touch $LOG_PATH/$MANIFEST_NAME

    svn export -q -r $IVERSION $IBUILD_SVN_OPTION svn://$IVERSION_SVN_SRV/iversion/$IVER_MANIFEST_URL $LOG_PATH/manifest-r$IVERSION.xml
    rm -f .repo/manifests/manifest-r*.xml >/dev/null 2>&1
    cp $LOG_PATH/manifest-r$IVERSION.xml .repo/manifests/

    SPLIT_LINE repo_init_$IBUILD_GRTSRV_MANIFEST
    echo "$REPO_CMD init -u ssh://$IBUILD_GRTSRV/$IBUILD_GRTSRV_URL $REPO_INIT_CMD" >repo_init.info
    /bin/bash repo_init.info >>$AUTOUT_PATH/log/init.log 2>&1
    export REPO_INIT_STATUS=$?
    MASK_LOG $AUTOUT_PATH/log/init.log
    LOG_STATUS $REPO_INIT_STATUS repo_init $AUTOUT_PATH/log/init.log
 else
    export REPO_SYNC_OPTION=''
 fi

 $IBUILD_ROOT/hotfix/clean_dirty.sh >/dev/null 2>&1

 SPLIT_LINE "repo_sync $REPO_SYNC_OPTION"
 pwd >$LOG_PATH/$REPO_SYNC_LOG_NAME.log
 time $REPO_CMD sync -j$JOBS --force-sync $REPO_SYNC_OPTION >>$LOG_PATH/$REPO_SYNC_LOG_NAME.log 2>&1
 export STATUS_SYNC=$?

# if [[ $STATUS_SYNC != 0 && -e $(pwd)/.repo && -e $(pwd).info ]] ; then
#    mkdir old
#    mv * .repo old/
#    bash $(pwd).info
#    time $REPO_CMD sync -j$JOBS --force-sync $REPO_SYNC_OPTION >>$LOG_PATH/$REPO_SYNC_LOG_NAME.log 2>&1
#    rm -fr old
# fi

 [[ -e $LOG_PATH ]] && rm -f log && ln -sf $LOG_PATH
 [[ -e /local/out ]] && rm -f out && ln -sf /local/out

 BTRFS_CLEANUP_SUBV_REPO
# && $REPO_CMD sync -j$JOBS --force-sync >/dev/null 2>&1

# for INDEX_LOCK_REPO in $(grep index.lock $LOG_PATH/$REPO_SYNC_LOG_NAME.log 2>/dev/null | awk -F"'" {'print $2'} | awk -F'/.git' {'print $1'})
# do
#    rm -fr $INDEX_LOCK_REPO
#    export INDEX_LOCK=true
# done

# if [[ ! -z $INDEX_LOCK && ! -e $REPO_SYNC_MD5_INFO ]] ; then
#    time $REPO_CMD sync -j$JOBS --force-sync $REPO_SYNC_OPTION >$LOG_PATH/$REPO_SYNC_LOG_NAME.log 2>&1
#    export STATUS_SYNC=$?
# fi

 if [[ ! -e $REPO_SYNC_MD5_INFO ]] ; then
    EXPORT_MANIFEST $LOG_PATH/after_sync_manifest.xml
    LOG_STATUS $STATUS_SYNC repo_sync $LOG_PATH/$REPO_SYNC_LOG_NAME.log
    CCACHE_HOTFIX
 fi
}

SETUP_BUILD_REPO()
{
 BTRFS_CLEANUP $LOC_WORKSPACE/build

 for BTRFS_OLD_PATH in $(ls $LOC_WORKSPACE/build/)
 do
    BTRFS_CLEANUP $LOC_WORKSPACE/build/$BTRFS_OLD_PATH
 done

 SPLIT_LINE snapshot_$BUILD_PATH_TOP 
 time btrfs subvolume snapshot $LOC_SUBV_REPO $BUILD_PATH_TOP >>$LOG_PATH/fs_issue.log 2>&1
 LOG_STATUS $? snapshot_$BUILD_PATH_TOP $LOG_PATH/fs_issue.log

 REPO_SYNC $BUILD_PATH_TOP
 if [[ ! -z $IBUILD_GRTSRV_TAG && $IBUILD_GRTSRV_TAG != NULL ]] ; then
    SPLIT_LINE git_checkout_$IBUILD_GRTSRV_TAG
    time $REPO_CMD forall -j$JOBS -c git checkout $IBUILD_GRTSRV_TAG >$LOG_PATH/$IBUILD_GRTSRV_TAG.log 2>&1
 fi
 [[ -e $BUILD_PATH_TOP && $(pwd) != $BUILD_PATH_TOP ]] && cd $BUILD_PATH_TOP
}

CCACHE_HOTFIX()
{
 export NEW_CCACHE_URL=$IBUILD_ROOT/bin/ccache
 export ORIG_CCACHE_URL=prebuilts/misc/linux-x86/ccache/ccache
 export NEW_MD5=$(md5sum $NEW_CCACHE_URL | awk -F' ' {'print $1'})
 export ORIG_MD5=$(md5sum $ORIG_CCACHE_URL | awk -F' ' {'print $1'})

 if [[ -e $ORIG_CCACHE_URL && $NEW_MD5 != $ORIG_MD5 ]] ; then
    /bin/cp $NEW_CCACHE_URL $ORIG_CCACHE_URL >/dev/null 2>&1
 fi
}

SETUP_ISTATUS()
{
 export ISTATUS_ENTRY=$1
    [[ -z $ITASK_REV ]] && export ITASK_REV=$(ls /tmp | grep log$ | grep -v old | grep build- | awk -F'-' {'print $2'}| awk -F'.log' {'print $1'} | tail -n1)

 if [[ ! -e $AUTOUT_UPLOAD_PATH/README ]] ; then
    sshfs -o nonempty -p 2222 sshfs@$IBUILD_UPLOAD_URL $AUTOUT_UPLOAD_PATH >$LOG_PATH/sshfs.log 2>&1
    export MOUNT_STATUS=$?
    LOG_STATUS $MOUNT_STATUS sshfs_$AUTOUT_UPLOAD_PATH $LOG_PATH/sshfs.log
 fi

 mkdir -p $AUTOUT_UPLOAD_PATH/$TODAY/istatus >/dev/null 2>&1
 touch $AUTOUT_UPLOAD_PATH/$TODAY/istatus/$ITASK_REV
 touch $AUTOUT_UPLOAD_PATH/$TODAY/istatus/$ITASK_ORDER

 if [[ $ITASK_REV = $ITASK_ORDER && -e $AUTOUT_UPLOAD_PATH/$TODAY/istatus/$ITASK_REV ]] ; then
    if [[ ! $(grep "|ibuild assign: $ITASK_REV" $AUTOUT_UPLOAD_PATH/$TODAY/istatus/$ITASK_REV) ]] ; then
       echo $(date +%y%m%d-%H%M%S)"|$HOSTNAME|ibuild assign: $ITASK_REV $IP" >>$AUTOUT_UPLOAD_PATH/$TODAY/istatus/$ITASK_REV
    fi
    echo $(date +%y%m%d-%H%M%S)"|$HOSTNAME|$ISTATUS_ENTRY" >>$AUTOUT_UPLOAD_PATH/$TODAY/istatus/$ITASK_REV
 elif [[ ! -z $ITASK_ORDER && -e $AUTOUT_UPLOAD_PATH/$TODAY/istatus/$ITASK_REV ]] ; then
    if [[ ! $(grep "|ibuild assign: $ITASK_REV" $AUTOUT_UPLOAD_PATH/$TODAY/istatus/$ITASK_ORDER) ]] ; then
        echo $(date +%y%m%d-%H%M%S)"|$HOSTNAME|ibuild assign: $ITASK_REV $IP" >>$AUTOUT_UPLOAD_PATH/$TODAY/istatus/$ITASK_ORDER
    fi
    echo $(date +%y%m%d-%H%M%S)"|$HOSTNAME|$ISTATUS_ENTRY" >>$AUTOUT_UPLOAD_PATH/$TODAY/istatus/$ITASK_ORDER
 fi
}

SETUP_ISTATUS_OLD()
{
 export ISTATUS_ENTRY=$1
    [[ -z $ITASK_REV ]] && export ITASK_REV=$(ls /tmp | grep log$ | grep -v old | grep build- | awk -F'-' {'print $2'}| awk -F'.log' {'print $1'} | tail -n1)

 if [[ ! -e $TASK_SPACE/istatus-$TOYEAR ]] ; then
    rm -fr $TASK_SPACE/istatus-* >/dev/null 2>&1
    svn co -q $IBUILD_SVN_OPTION svn://$ISTATUS_SVN_SRV/istatus/$TOYEAR $TASK_SPACE/istatus-$TOYEAR
    if [[ $? != 0 ]] ; then
        svn mkdir -q --parents $IBUILD_SVN_OPTION -m "auto: add istatus/$TOYEAR" svn://$ISTATUS_SVN_SRV/istatus/$TOYEAR
        svn co -q $IBUILD_SVN_OPTION svn://$ISTATUS_SVN_SRV/istatus/$TOYEAR $TASK_SPACE/istatus-$TOYEAR
    fi
 else
    svn up -q $IBUILD_SVN_OPTION $TASK_SPACE/istatus-$TOYEAR
 fi
 
 touch $TASK_SPACE/istatus-$TOYEAR/$ITASK_REV
 touch $TASK_SPACE/istatus-$TOYEAR/$ITASK_ORDER

 if [[ $ITASK_REV = $ITASK_ORDER && -e $TASK_SPACE/istatus-$TOYEAR/$ITASK_REV ]] ; then
    if [[ ! $(grep "|ibuild assign: $ITASK_REV" $TASK_SPACE/istatus-$TOYEAR/$ITASK_REV) ]] ; then
        echo $(date +%y%m%d-%H%M%S)"|$HOSTNAME|ibuild assign: $ITASK_REV $IP" >>$TASK_SPACE/istatus-$TOYEAR/$ITASK_REV
    fi
    echo $(date +%y%m%d-%H%M%S)"|$HOSTNAME|$ISTATUS_ENTRY" >>$TASK_SPACE/istatus-$TOYEAR/$ITASK_REV
 elif [[ ! -z $ITASK_ORDER && -e $TASK_SPACE/istatus-$TOYEAR/$ITASK_REV ]] ; then
    if [[ ! $(grep "|ibuild assign: $ITASK_REV" $TASK_SPACE/istatus-$TOYEAR/$ITASK_ORDER) ]] ; then
        echo $(date +%y%m%d-%H%M%S)"|$HOSTNAME|ibuild assign: $ITASK_REV $IP" >>$TASK_SPACE/istatus-$TOYEAR/$ITASK_ORDER
    fi
    echo $(date +%y%m%d-%H%M%S)"|$HOSTNAME|$ISTATUS_ENTRY" >>$TASK_SPACE/istatus-$TOYEAR/$ITASK_ORDER
 fi

 svn add $TASK_SPACE/istatus-$TOYEAR/$ITASK_REV >/dev/null 2>&1
 svn add $TASK_SPACE/istatus-$TOYEAR/$ITASK_ORDER >/dev/null 2>&1

 while [ $(ls $TASK_SPACE/istatus-$TOYEAR | wc -l) -ge 100 ] ;
 do
    export OLD_STATUS=$(ls $TASK_SPACE/istatus-$TOYEAR | head -n1)
    svn rm -q --force $TASK_SPACE/istatus-$TOYEAR/$OLD_STATUS
 done

 svn up -q $IBUILD_SVN_OPTION $TASK_SPACE/istatus-$TOYEAR/
 svn ci -q $IBUILD_SVN_OPTION -m "auto: add $ITASK_REV and clean old" $TASK_SPACE/istatus-$TOYEAR/*
 if [[ $? != 0 ]] ; then
    rm -fr $TASK_SPACE/istatus-$TOYEAR >/dev/null 2>&1
 fi
}

SETUP_IVERSION()
{
 export ORIG_MANIFEST_URL=$1
 export IVER_MANIFEST_NAME=$2.xml

 if [[ -e $TASK_SPACE/iversion-$TOYEAR/.svn ]] ; then
    svn up -q $IBUILD_SVN_OPTION $TASK_SPACE/iversion-$TOYEAR
 else
    rm -fr $TASK_SPACE/iversion-*
    svn mkdir -q --parents $IBUILD_SVN_OPTION -m "auto: add iversion/$TOYEAR" svn://$IVERSION_SVN_SRV/iversion/iversion/$TOYEAR >/dev/null 2>&1
    svn co -q $IBUILD_SVN_OPTION svn://$IVERSION_SVN_SRV/iversion/iversion/$TOYEAR $TASK_SPACE/iversion-$TOYEAR
 fi
 export LATEST_MANIFEST=$(ls $TASK_SPACE/iversion-$TOYEAR | grep xml$ | tail -n1)
    [[ ! -z $LATEST_MANIFEST ]] && svn cp $TASK_SPACE/iversion-$TOYEAR/$LATEST_MANIFEST $TASK_SPACE/iversion-$TOYEAR/$IVER_MANIFEST_NAME >/dev/null 2>&1
 cp $ORIG_MANIFEST_URL $TASK_SPACE/iversion-$TOYEAR/$IVER_MANIFEST_NAME
 export MANIFEST_VER=$(md5sum $TASK_SPACE/iversion-$TOYEAR/$IVER_MANIFEST_NAME | cut -c1-5)

 svn add $TASK_SPACE/iversion-$TOYEAR/$IVER_MANIFEST_NAME >/dev/null 2>&1
 svn ci -q $IBUILD_SVN_OPTION -m "auto: add $IVER_MANIFEST_NAME" $TASK_SPACE/iversion-$TOYEAR/$IVER_MANIFEST_NAME >/dev/null 2>&1
 if [[ $? = 0 ]] ; then
#    export IBUILD_ID=$(echo $BUILD_TIME | cut -c7-8).r$(svn info $TASK_SPACE/iversion-$TOYEAR/$IVER_MANIFEST_NAME | grep 'Last Changed Rev: ' | awk -F': ' {'print $2'})
     if [[ -z $IBUILD_ID && ! -z $BUILD_NUMBER && -z $IVERSION ]] ; then
         export IBUILD_ID=r$BUILD_NUMBER
     elif [[ -z $IBUILD_ID && ! -z $IVERSION ]] ; then
         export IBUILD_ID=r$(svn info $TASK_SPACE/iversion-$TOYEAR/$IVER_MANIFEST_NAME | grep 'Last Changed Rev: ' | awk -F': ' {'print $2'})
     elif [[ -z $IBUILD_ID && -z $BUILD_NUMBER ]] ; then
         export BUILD_NUMBER=$(svn info $TASK_SPACE/iversion-$TOYEAR/$IVER_MANIFEST_NAME | grep 'Last Changed Rev: ' | awk -F': ' {'print $2'})
         export IBUILD_ID=r$(svn info $TASK_SPACE/iversion-$TOYEAR/$IVER_MANIFEST_NAME | grep 'Last Changed Rev: ' | awk -F': ' {'print $2'})
     fi
 else
     SPLIT_LINE iversion_issue
     echo $IVER_MANIFEST_NAME
         [[ -z $IBUILD_ID ]] && export IBUILD_ID=$(echo $BUILD_TIME | cut -c7-8).$MANIFEST_VER
 fi
 SPLIT_LINE "$IVER_MANIFEST_NAME $IBUILD_ID"
 echo $IBUILD_ID >$LOCK_SPACE/IBUILD_ID
 echo $BUILD_NUMBER >$LOCK_SPACE/BUILD_NUMBER
}

SETUP_ICASE()
{
 local ICASE_UPLOAD_URL=$1

 if [[ -z $END_SEC_TIME ]] ; then
    export TIME_END=$(date +%y%m%d%H%M%S)
    export END_SEC_TIME=$(date +%s)
 fi

 [[ -z $RESULT ]] && export RESULT=ISSUE

 echo "RESULT=$RESULT
STATUS_SYNC=$STATUS_SYNC
STATUS_GIT=$STATUS_GIT
STATUS_REPO=$STATUS_REPO
STATUS_MAKE=$STATUS_MAKE
STATUS_MAKE_REL=$STATUS_MAKE_REL
EMAIL_PATCH_OWNER=$EMAIL_PATCH_OWNER
SLAVE_HOST=$(hostname)
BUILD_NUMBER=$BUILD_NUMBER
SLAVE_IP=$IP
TIME_START=$BUILD_TIME
TIME_END=$TIME_END
IBUILD_ID=$IBUILD_ID
IVERSION=$IVERSION
MANIFEST_NAME=$MANIFEST_NAME
ITASK_REV=$ITASK_REV
BUILD_TIME=$(echo $END_SEC_TIME - $BUILD_SEC_TIME | bc)
REL_PATH=$TODAY/$AUTOUT_NAME
GERRIT_TOPIC=$GERRIT_TOPIC
GERRIT_CHANGE_NUMBER=$GERRIT_CHANGE_NUMBER
GERRIT_CHANGE_ID=$GERRIT_CHANGE_ID
GERRIT_CHANGE_URL=$GERRIT_CHANGE_URL
GERRIT_CHANGE_OWNER_EMAIL=$GERRIT_CHANGE_OWNER_EMAIL
GERRIT_CHANGE_OWNER_NAME=$GERRIT_CHANGE_OWNER_NAME
GERRIT_PATCHSET_NUMBER=$GERRIT_PATCHSET_NUMBER
GERRIT_PATCHSET_REVISION=$GERRIT_PATCHSET_REVISION
GERRIT_PROJECT=$GERRIT_PROJECT
DOWNLOAD_URL=http://$IBUILD_DOWNLOAD_SRV/build/$ICASE_UPLOAD_URL
DOWNLOAD_PKG_NAME=$DOWNLOAD_PKG_NAME
REMOTE_NAME=$REMOTE_NAME
" | grep -v '=$' >>$LOG_PATH/build_info.txt

 if [[ $(grep '^RESULT=' $LOG_PATH/build_info.txt | wc -l) != 1 ]] ; then
    grep -v '^RESULT=' $LOG_PATH/build_info.txt >$LOG_PATH/build_info.tmp
    cp $LOG_PATH/build_info.tmp $LOG_PATH/build_info.txt
    echo 'RESULT=ISSUE' >>$LOG_PATH/build_info.txt
 fi

 [[ ! -z $IVERIFY && $RESULT = PASSED ]] && SETUP_ISTATUS "iverify globe queue: queue/icase"
 if [[ $ITASK_ORDER != $ITASK_TMP ]] ; then
    [[ -z $ITASK_ORDER && ! -z $ITASK_TMP ]] && export ITASK_ORDER=$ITASK_TMP
    echo "ITASK_ORDER=$ITASK_ORDER" >>$LOG_PATH/build_info.txt
 fi
 cat $LOG_PATH/build_info.txt | sort -u | grep -v ^$ >$LOG_PATH/build_info.tmp
 mv $LOG_PATH/build_info.tmp $LOG_PATH/build_info.txt
 
 if [[ -e $TASK_SPACE/icase-$TOWEEK ]] ; then
    svn up -q $IBUILD_SVN_OPTION $TASK_SPACE/icase-$TOWEEK
 else
    rm -fr $TASK_SPACE/icase-*
    svn mkdir -q --parents $IBUILD_SVN_OPTION -m "auto: add icase/$TOYEAR/$TOWEEK" svn://$ICASE_SVN_SRV/icase/icase/$TOYEAR/$TOWEEK
    svn co -q $IBUILD_SVN_OPTION svn://$ICASE_SVN_SRV/icase/icase/$TOYEAR/$TOWEEK $TASK_SPACE/icase-$TOWEEK
 fi

 if [[ ! -z $ITASK_REV ]] ; then
    export IVEREV=$IBUILD_ID.$ITASK_REV
 else
    export IVEREV=$IBUILD_ID
 fi
 cp $LOG_PATH/build_info.txt $TASK_SPACE/icase-$TOWEEK/$IVEREV.build_info.txt
 svn add $TASK_SPACE/icase-$TOWEEK/$IVEREV.build_info.txt >/dev/null 2>&1
 svn ci -q $IBUILD_SVN_OPTION -m "auto: add $IVEREV.build_info.txt" $TASK_SPACE/icase-$TOWEEK/$IVEREV.build_info.txt
 cp $LOG_PATH/build_info.txt $AUTOUT_UPLOAD_PATH/$ICASE_UPLOAD_URL/
}

EXPORT_MANIFEST()
{
 export EXPORT_MANIFEST_URL=$1
 export EXPORT_MANIFEST_PATH=$(dirname $EXPORT_MANIFEST_URL)
 SPLIT_LINE export_manifest
 time $REPO_CMD manifest -r -o tmp_manifest.xml >/dev/null 2>&1
 export MANIFEST_VER=$(md5sum tmp_manifest.xml | cut -c1-5)
 /bin/cp tmp_manifest.xml $EXPORT_MANIFEST_URL >/dev/null 2>&1
 /bin/cp tmp_manifest.xml $EXPORT_MANIFEST_PATH/manifest.xml >/dev/null 2>&1
 if [[ -e Makefile && ! -z $AUTOUT_NAME ]] ; then
    rm -f autout >/dev/null 2>&1
    ln -sf $AUTOUT_PATH/$AUTOUT_NAME autout >/dev/null 2>&1
    [[ ! -z $OUT ]] && rm -f $OUT/autout ; ln -sf $AUTOUT_PATH/$AUTOUT_NAME $OUT/autout >/dev/null 2>&1
 fi
 [[ $(echo $EXPORT_MANIFEST_URL | grep before_build) ]] && SETUP_IVERSION $EXPORT_MANIFEST_PATH/manifest.xml $HOSTNAME.$AUTOUT_NAME
}

DIFF_MANIFEST()
{
 export DIFF_MANIFEST=''
 export MANIFEST_MD5=$(md5sum $LOG_PATH/manifest.xml | awk -F' ' {'print $1'})
 if [[ -e $TASK_SPACE/iversion-$TOYEAR ]] ; then
    svn up -q $IBUILD_SVN_OPTION $TASK_SPACE/iversion-$TOYEAR
 else
    svn co -q $IBUILD_SVN_OPTION svn://$IVERSION_SVN_SRV/iversion/iversion/$TOYEAR $TASK_SPACE/iversion-$TOYEAR
 fi
 if [[ $(md5sum $TASK_SPACE/iversion-$TOYEAR/*itest* | grep $MANIFEST_MD5) ]] ; then
     touch $LOG_PATH/nobuild
 fi
}

SETUP_BUILD_OUT()
{
 [[ -e $BUILD_PATH_TOP && $(pwd) != $BUILD_PATH_TOP ]] && cd $BUILD_PATH_TOP
 if [[ -z $OUT ]] ; then
    cd $BUILD_PATH_TOP
    source build/envsetup.sh >/dev/null 2>&1
    lunch $IBUILD_TARGET_PRODUCT-$IBUILD_TARGET_BUILD_VARIANT >/dev/null 2>&1
 fi
 [[ -e $OUT/system/build.prop ]] && cp $OUT/system/build.prop $BUILD_PATH_TOP/autout/ >/dev/null 2>&1

 if [[ $RESULT != FAILED ]] ; then
    if [[ -e $BUILD_PATH_TOP/release ]] ; then
        cp $OUT/system/build.prop $BUILD_PATH_TOP/release/ >/dev/null 2>&1
        [[ -z $BUILD_NUMBER ]] && export BUILD_NUMBER=$(cat $LOCK_SPACE/BUILD_NUMBER)
        export RELEASE_VER=$BUILD_NUMBER
        tar cf $BUILD_PATH_TOP/autout/release.$RELEASE_VER.tar release
        export DOWNLOAD_PKG_NAME=release.$RELEASE_VER.tar
#        tar cfz $BUILD_PATH_TOP/autout/release.$RELEASE_VER.tgz release
#        export DOWNLOAD_PKG_NAME=release.$RELEASE_VER.tgz
    elif [[ $(ls $BUILD_PATH_TOP/autout/ | grep 'release' | head -n1) ]] ; then
        export DOWNLOAD_PKG_NAME=$(ls $BUILD_PATH_TOP/autout/ | grep 'release' | head -n1)
    elif [[ $TARGET_PRODUCT = sdk ]] ; then
        export DOWNLOAD_PKG_NAME=$(ls $BUILD_PATH_TOP/autout/ | grep android-sdk | grep zip$)
    else
        SPLIT_LINE no_release_package
    fi
 fi

 [[ -z $BUILD_NUMBER || -z $IBUILD_ID ]] && SETUP_IVERSION $LOG_PATH/manifest.xml $HOSTNAME.$AUTOUT_NAME
 if [[ ! -z $ITASK_REV ]] ; then
    export IVEREV=$IBUILD_ID.$ITASK_REV
 else
    export IVEREV=$IBUILD_ID
 fi

 LOG_HTML $LOG_PATH $LOG_PATH
 cp -Ra $AUTOUT_PATH/log/* $LOG_PATH/ >/dev/null 2>&1
 [[ -e $LOG_PATH/BUILD_ERROR ]] && export IVEREV=$IVEREV.BUILD_ERROR
 export SHORT_AUTOUT_NAME=$(echo $AUTOUT_NAME | sed 's/.not_define.//g')
 mv $AUTOUT_PATH/$AUTOUT_NAME $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME
 export LOG_PATH=$AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME/log

# please setup run_sshd.sh in docker
 if [[ ! -e $LOC_WORKSPACE/upload/README ]] ; then
     sshfs -o nonempty -p 2222 sshfs@$IBUILD_UPLOAD_URL $LOC_WORKSPACE/upload >$LOG_PATH/sshfs.log 2>&1
     export MOUNT_STATUS=$?
     LOG_STATUS $MOUNT_STATUS sshfs_$LOC_WORKSPACE/upload $LOG_PATH/sshfs.log
 fi

 mkdir -p $AUTOUT_UPLOAD_PATH/$TODAY
 SPLIT_LINE "upload $TODAY $IVEREV.$SHORT_AUTOUT_NAME"
    [[ -z $ITASK_REV ]] && export ITASK_REV=$(ls /tmp | grep log$ | grep -v old | grep build- | awk -F'-' {'print $2'}| awk -F'.log' {'print $1'} | tail -n1)
 [[ -e /tmp/build-$ITASK_REV.log ]] && LOG_HTML /tmp/build-$ITASK_REV.log $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME/log/ >/dev/null 2>&1
# [[ -e /tmp/build-$ITASK_REV.log ]] && txt2html /tmp/build-$ITASK_REV.log --outfile $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME/build-$ITASK_REV.log.html
 [[ -e /tmp/build-$ITASK_REV.log ]] && cp /tmp/build-$ITASK_REV.log $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME/build-$ITASK_REV.log.txt

 if [[ -e $LOG_PATH/BUILD_ERROR ]] ; then
    cp $LOG_PATH/BUILD_ERROR $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME/ >/dev/null 2>&1
    cp /tmp/build-*.log $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME/ >/dev/null 2>&1
 else
    export RESULT=PASSED
 fi

 time cp -R $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME $AUTOUT_UPLOAD_PATH/$TODAY/ >/dev/null 2>&1
 export STATUS_CP=$?

 if [[ $AUTOUT_UPLOAD_PATH = $DIST_FS_SHARE && -e $LOC_WORKSPACE/upload/README ]] ; then
    [[ -e $LOG_PATH/BUILD_ERROR && ! $(echo $IVEREV | grep BUILD_ERROR) ]] && export BUILD_ERROR=.BUILD_ERROR
    mkdir -p $LOC_WORKSPACE/upload/$TODAY >/dev/null 2>&1
    ln -sf /local/share/DIST_FS/$HOSTNAME/$TODAY/$IVEREV$BUILD_ERROR.$SHORT_AUTOUT_NAME $LOC_WORKSPACE/upload/$TODAY/
 fi

 SETUP_ICASE $TODAY/$IVEREV.$SHORT_AUTOUT_NAME
 if [[ $STATUS_CP = 0 ]] ; then
    rm -fr $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME &
 fi
}

LOG_HTML()
{
 export LOG_INPUT_URL=$1
 export LOG_OUTPUT_URL=$2

 rm -f $LOG_INPUT_URL/log $LOG_OUTPUT_URL/log >/dev/null 2>&1

 for LOG_NAME in $(ls $LOG_INPUT_URL | egrep -v 'xml$|txt$|BUILD_ERROR' | grep log$)
 do
#    txt2html $LOG_INPUT_URL/$LOG_NAME --outfile $LOG_OUTPUT_URL/$LOG_NAME.html
     mv $LOG_INPUT_URL/$LOG_NAME $LOG_INPUT_URL/$LOG_NAME.txt
#    [[ $(echo $LOG_NAME | egrep 'sync|full_build') && -e $LOG_OUTPUT_URL/$LOG_NAME.html ]] && rm -e $LOG_INPUT_URL/$LOG_NAME
 done
}

BUILD_ERROR()
{
 touch $LOG_PATH/BUILD_ERROR

 export CHECK_LOG=$1
 export CHECK_LOG_NAME=$(basename $CHECK_LOG)
# export ERROR_FILTER='cannot |not |No |no |failed|Error |error:|lost|duplicate annotation|unreported|illegal |expected|duplicate attribute|has private access|uses or overrides|expected constructor|undefined reference|duplicate case label|unqualified enumeration|die|incompatible types|incompatible types|already defined|has private access|overrides|illegal start of expression|doesn|This attribute must be localized|unbound prefix|cannot find symbol|ERROR Resource entry|No resource found that matches the given name|Link to hidden class|Parameter of hidden type|too many initializers|Resource is not public|illegal start of expression|make: ***|Stop'
  export ERROR_FILTER='cannot | failed |error: package |duplicate annotation|cannot find symbol|ERROR Resource entry|No resource found that matches the given name|make: ***|fatal error: |file not found|Errot 41|Error 1|error: method does not override or implement a method from a supertype|error: could not apply |hint: after resolving the conflicts'

 if [[ $(echo $CHECK_LOG | grep full_build) ]] ; then
    if [[ $(cat $CHECK_LOG | wc -l) -ge 100 ]] ; then
        cat $CHECK_LOG | grep -v -i warning | egrep -v '^dex2oatd |^Warning |^warning: |^:|^Note: |^Notice file: |^Copying: |^Install: |^INFO: |^target |BUILD SUCCESSFUL' | uniq >>$LOG_PATH/error.log
    else
        cat $CHECK_LOG >>$LOG_PATH/error.log
    fi
 elif [[ -e $CHECK_LOG ]] ; then
    tail -n 50 $CHECK_LOG
    cp $CHECK_LOG $LOG_PATH/error.log
 else
    echo "$CHECK_LOG does not exist" >>$LOG_PATH/error.log
 fi
# tail -n30 $LOG_PATH/error.log
 cat $LOG_PATH/error.log | egrep -3 "$ERROR_FILTER" | tail -n30
}

CLEAN_EXIT()
{
 rm -fr /tmp/tmp.*
 rm -f $LOC_WORKSPACE/autout/log/*
 rm -fr $TASK_SPACE/*spec.build*
 rm -f $LOCK_SPACE/itask.lock
 rm -fr $AUTOUT_PATH/r*
 rm -fr $AUTOUT_PATH/*BUILD_ERROR* >/dev/null 2>&1
 rm -fr $LOG_PATH/*BUILD_ERROR* >/dev/null 2>&1
 [[ -e /tmp/build-$ITASK_REV.log ]] && mv /tmp/build-$ITASK_REV.log /tmp/old.build-$ITASK_REV.log
 if [[ -e $ORIG_CCACHE_URL ]] ; then
    export CCACHE_MAX_SIZE=$($ORIG_CCACHE_URL -s | grep size | grep max | awk -F' ' {'print $4'} | awk -F'.' {'print $1'}) 
    export CCACHE_SIZE=$($ORIG_CCACHE_URL -s | grep size | grep -v max | awk -F' ' {'print $3'} | awk -F'.' {'print $1'})
    [[ $(echo $CCACHE_MAX_SIZE - $CCACHE_SIZE | bc) -le 10 ]] && $ORIG_CCACHE_URL -Cc && $ORIG_CCACHE_URL -M 150G
 fi
 pkill -9 java
 pkill -9 javadoc
 pkill -9 aapt
 exit $1
}

LOG_STATUS()
{
 export CHECK_STATUS=$1
 export CHECK_SUBJECT=$2
 export CHECK_LOG=$3
 export CHECK_LOG_NAME=$(basename $CHECK_LOG)

 SETUP_ISTATUS "$CHECK_STATUS: $CHECK_SUBJECT" $ITASK_REV

 MASK_LOG $CHECK_LOG
 if [[ $CHECK_STATUS != 0 ]] ; then
    SPLIT_LINE "ERROR LOG: $CHECK_SUBJECT"
    BUILD_ERROR $CHECK_LOG
    export RESULT=FAILED
    echo $CHECK_LOG >$LOG_PATH/BUILD_ERROR
    SETUP_BUILD_OUT
    sleep 5 && pkill -9 $IBUILD_MAKE_TOOL >/dev/null 2>&1 &

    SPLIT_LINE "STOP_BUILD $CHECK_LOG_NAME"
    CLEAN_EXIT $CHECK_STATUS
 else
    [[ -z $RESULT ]] && export RESULT=PASSED
 fi
}

REPO_DOWNLOAD()
{
 cd $BUILD_PATH_TOP
 SPLIT_LINE "repo download $GERRIT_PROJECT $GERRIT_CHANGE_NUMBER/$GERRIT_PATCHSET_NUMBER"
 time $REPO_CMD download $GERRIT_PROJECT $GERRIT_CHANGE_NUMBER/$GERRIT_PATCHSET_NUMBER >>$LOG_PATH/repo_download.log 2>&1
 export STATUS_REPO=$?
 LOG_STATUS $STATUS_REPO repo_download $LOG_PATH/repo_download.log
}

GIT_CHERRY_PICK()
{
 GET_REMOTE_NAME

 export LOCAL_PROJECT_PATH=$(cat /tmp/repo.list | egrep ": $REAL_GERRIT_PROJECT$" | awk -F':' {'print $1'} | head -n1)
 export MANIFEST_PATCHSET=''

 if [[ $(echo $GERRIT_PROJECT | grep manifests$) ]] ; then
    export MANIFEST_PATCHSET=true
    export LOCAL_PROJECT_PATH=.repo/manifests
    SPLIT_LINE manifest_change
 fi

 cd $BUILD_PATH_TOP/$LOCAL_PROJECT_PATH

 if [[ $? != 0 || -z $LOCAL_PROJECT_PATH ]] ; then
    SPLIT_LINE "nobuild: Cannot find $GERRIT_PROJECT local path"
    touch $LOG_PATH/nobuild
    exit 0
 fi

 git remote update
 git clean -fxd

 SPLIT_LINE "git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC"
 git fetch ssh://$IBUILD_GRTSRV/$FETCH_GERRIT_PROJECT $GERRIT_REFSPEC >>$LOG_PATH/patch.log 2>&1
 export CHECK_STATUS=$?
 LOG_STATUS $CHECK_STATUS git_fetch $LOG_PATH/patch.log
 export COMMIT_SHA1=$(git log FETCH_HEAD | head -n1 | awk -F' ' {'print $2'})

 git diff HEAD FETCH_HEAD >/tmp/diff-$NOW.tmp

 if [[ ! $(git log HEAD | grep $COMMIT_SHA1) && ! $(md5sum /tmp/diff-$NOW.tmp | grep d41d8cd98f00b204e9800998ecf8427e) ]] ; then
    rm -f /tmp/diff-$NOW.tmp
    SPLIT_LINE "git cherry-pick FETCH_HEAD"
    git cherry-pick FETCH_HEAD >>$LOG_PATH/patch.log 2>&1
    export CHECK_STATUS=$?
    if [[ $CHECK_STATUS != 0 ]] ; then
        SPLIT_LINE "git cherry-pick -m 1 FETCH_HEAD"
        git cherry-pick --abort >>$LOG_PATH/patch.log 2>&1
        git reset --hard >>$LOG_PATH/patch.log 2>&1
        git clean -fxd >>$LOG_PATH/patch.log 2>&1
        git cherry-pick -m 1 FETCH_HEAD >>$LOG_PATH/patch.log 2>&1
        export CHECK_STATUS=$?
    fi
    if [[ $CHECK_STATUS != 0 ]] ; then
        SPLIT_LINE "git cherry-pick -m 2 FETCH_HEAD"
        git cherry-pick --abort >>$LOG_PATH/patch.log 2>&1
        git reset --hard >>$LOG_PATH/patch.log 2>&1
        git clean -fxd >>$LOG_PATH/patch.log 2>&1
        git cherry-pick -m 2 FETCH_HEAD >>$LOG_PATH/patch.log 2>&1
        export CHECK_STATUS=$?
    fi
    [[ $CHECK_STATUS != 0 ]] && git status >>$LOG_PATH/patch.log 2>&1
    LOG_STATUS $CHECK_STATUS cherry_pick $LOG_PATH/patch.log
 else
    SPLIT_LINE "MERGED: $GERRIT_PROJECT $GERRIT_REFSPEC"
    touch $LOG_PATH/nobuild
    rm -f /tmp/diff-$NOW.tmp
    exit 0
 fi
 cd $BUILD_PATH_TOP

 if [[ $MANIFEST_PATCHSET = true ]] ; then
    SPLIT_LINE "Clean workspace and sync again"
    for RM_ENTRY in $(cat /tmp/repo.list | awk -F':' {'print $1'} | awk -F'/' {'print $1'} | sort -u)
    do
        rm -fr $BUILD_PATH_TOP/$RM_ENTRY
    done
    $REPO_CMD sync -d -c -q --force-sync -j$JOBS --no-tags
    CHECK_STATUS $?
 fi
}

GET_ICHANGE_STRING()
{
 export ICHANGE_STRING=$1
 export STRING_GERRIT_revision=$(echo $ICHANGE_STRING | awk -F'|' {'print $1'})
 export STRING_GERRIT_id=$(echo $ICHANGE_STRING | awk -F'|' {'print $2'})
 export STRING_GERRIT_email=$(echo $ICHANGE_STRING | awk -F'|' {'print $3'})
    [[ -z $STRING_GERRIT_email ]] && export STRING_GERRIT_email=no_mail
 export STRING_GERRIT_PATH=$(echo $ICHANGE_STRING | awk -F'|' {'print $4'})
 export STRING_GERRIT_PROJECT=$(echo $ICHANGE_STRING | awk -F'|' {'print $5'})
 export STRING_GERRIT_change_number=$(echo $ICHANGE_STRING | awk -F'|' {'print $6'})
 export STRING_GERRIT_patchSet_number=$(echo $ICHANGE_STRING | awk -F'|' {'print $7'})
 export STRING_GERRIT_value=$(echo $ICHANGE_STRING | awk -F'|' {'print $8'})
}

TIMEOUT_KILL()
{
 export TIMEOUT_KILL_SLEEP=$1
 export TIMEOUT_KILL_TARGET=$2
 sleep $TIMEOUT_KILL_SLEEP
 pkill -9 $TIMEOUT_KILL_TARGET
}

