#!/bin/bash
# Copyright (C) <2014,2015>  <Ding Wei>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Change log
# 150120 Create by Ding Wei
source /etc/bash.bashrc
export LC_CTYPE=C
export LC_ALL=C
export USER=`whoami`
export TASK_SPACE=/run/shm
export IP=`/sbin/ifconfig | grep 'inet addr:' | grep -v 127.0.0.1 | awk -F':' {'print $2'} | awk -F' ' {'print $1'} | head -n1`
export MAC=`/sbin/ifconfig | grep HWaddr | awk -F'HWaddr ' {'print $2'} | head -n1`
export HOSTNAME=`hostname`
export DOMAIN_NAME=`cat /etc/resolv.conf | grep search | awk -F' ' {'print $2'}`
export JOBS=`cat /proc/cpuinfo | grep CPU | wc -l`
export TODAY=`date +%y%m%d`
export TOWEEK=`date +%yw%V`
export ITASK_PATH=$TASK_SPACE/itask/svn
export TOYEAR=`date +%Y`
export SEED=$RANDOM
export BUILD_TIME=`date +%y%m%d%H%M%S`
export BUILD_SEC_TIME=`date +%s`
export DISTRIB_ID=`grep '^DISTRIB_ID=' /etc/lsb-release | awk -F'=' {'print $2'}`
export DISTRIB_RELEASE=`grep '^DISTRIB_RELEASE=' /etc/lsb-release | awk -F'=' {'print $2'}`

export IBUILD_ROOT=$HOME/ibuild
        [[ -z $IBUILD_ROOT ]] && export IBUILD_ROOT=`dirname $0 | awk -F'/ibuild' {'print $1'}`'/ibuild'
if [[ ! -f $HOME/ibuild/conf/ibuild.conf ]] ; then
	echo -e "Please put ibuild in your $HOME"
	exit 0
fi
export LOCK_SPACE=/dev/shm/lock
mkdir -p $LOCK_SPACE >/dev/null 2>&1

export NETCAT=`which nc`
	[[ -z $NETCAT ]] && export NETCAT="$IBUILD_ROOT/bin/netcat.openbsd-u14.04"

$NETCAT 127.0.0.1 1234
# pkill -9 nc >/dev/null 2>&1

# sudo rm -f /root/ibuild >/dev/null 2>&1
# sudo ln -sf $HOME/ibuild /root/ibuild >/dev/null 2>&1

EXPORT_IBUILD_CONF()
{
 export IBUILD_SVN_SRV=`grep '^IBUILD_SVN_SRV=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IBUILD_SVN_SRV=' {'print $2'}`
 export IBUILD_SVN_OPTION=`grep '^IBUILD_SVN_OPTION=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IBUILD_SVN_OPTION=' {'print $2'}`
 export LOC_REPO_MIRROR_PATH=`grep '^LOC_REPO_MIRROR_PATH=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'LOC_REPO_MIRROR_PATH=' {'print $2'}`
 export LOC_WORKSPACE=`grep '^LOC_WORKSPACE=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'LOC_WORKSPACE=' {'print $2'}`
# mkdir -p /local/{ccache,out} >/dev/null 2>&1
 mkdir -p /local/workspace/{ref_repo,build} >/dev/null 2>&1
 [[ -z $CCACHE_DIR ]] && export CCACHE_DIR=`grep '^CCACHE_DIR=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'CCACHE_DIR=' {'print $2'}`
 [[ -z $CCACHE_UMASK ]] && export CCACHE_UMASK=`grep '^CCACHE_UMASK=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'CCACHE_UMASK=' {'print $2'}` 
 [[ -z $CCACHE_BASEDIR ]] && export CCACHE_BASEDIR=`grep '^CCACHE_BASEDIR=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'CCACHE_BASEDIR=' {'print $2'}`
 [[ -z $USE_CCACHE ]] && export USE_CCACHE=`grep '^USE_CCACHE=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'USE_CCACHE=' {'print $2'}`
 export JDK6_PATH=`grep '^JDK6_PATH=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'JDK6_PATH=' {'print $2'}`
 export JDK7_PATH=`grep '^JDK7_PATH=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'JDK7_PATH=' {'print $2'}`
 export IBUILD_GRTSRV_ID_DEFAULT=`grep '^IBUILD_GRTSRV_ID=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IBUILD_GRTSRV_ID=' {'print $2'}`
 export IBUILD_ROBOT=`grep '^IBUILD_ROBOT=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'IBUILD_ROBOT=' {'print $2'}`
 export REPO_CMD=`grep '^REPO_CMD=' $IBUILD_ROOT/conf/ibuild.conf | awk -F'REPO_CMD=' {'print $2'}`
}

EXPORT_IBUILD_SPEC()
{
 export ITASK_REV=$1
 if [[ ! -z $ITASK_REV ]] ; then
     svn up -q $IBUILD_SVN_OPTION $ITASK_PATH
     export IBUILD_SPEC_NAME=`svn log -v -r $ITASK_REV $IBUILD_SVN_OPTION svn://$IBUILD_SVN_SRV/itask/itask | egrep 'A |M ' | head -n1 | awk -F'tasks/' {'print $2'} | awk -F' ' {'print $1'}`
     if [[ ! `grep IBUILD_GRTSRV $ITASK_PATH/tasks/$IBUILD_SPEC_NAME` ]] ; then
         SPLIT_LINE "$ITASK_PATH/tasks/$IBUILD_SPEC_NAME is not a spec.build"
         exit 1
     fi
     if [[ -f $ITASK_PATH/tasks/$IBUILD_SPEC_NAME && ! -f $TASK_SPACE/spec.build ]] ; then
         cp $ITASK_PATH/tasks/$IBUILD_SPEC_NAME $TASK_SPACE/
         ln -sf $TASK_SPACE/$IBUILD_SPEC_NAME $TASK_SPACE/spec.build
         echo -e "-------------------------\nStart build: $IBUILD_SPEC_NAME\n-------------------------" | wall >/dev/null 2>&1 
     else
         SPLIT_LINE "$ITASK_PATH/tasks/$IBUILD_SPEC_NAME is not a spec.build or $TASK_SPACE/spec.build locked"
         exit 1
     fi
 fi

 if [[ -L $TASK_SPACE/spec.build ]] ; then
        export IBUILD_SPEC=`readlink $TASK_SPACE/spec.build`
	[[ ! -f $IBUILD_SPEC ]] && export IBUILD_SPEC=$TASK_SPACE/$IBUILD_SPEC 
 elif [[ -f $TASK_SPACE/spec.build ]] ; then
	export IBUILD_SPEC=$TASK_SPACE/spec.build
 else
	SPLIT_LINE "No spec.build in $TASK_SPACE"
	exit 1
 fi

 export EMAIL_PM=`grep '^EMAIL_PM=' $IBUILD_SPEC | awk -F'EMAIL_PM=' {'print $2'}`
 export EMAIL_REL=`grep '^EMAIL_REL=' $IBUILD_SPEC | awk -F'EMAIL_REL=' {'print $2'}`
 export EMAIL_TMP=`grep '^EMAIL_TMP=' $IBUILD_SPEC | awk -F'EMAIL_TMP=' {'print $2'}`
 export IBUILD_AUTOUT_FILES=`grep '^IBUILD_AUTOUT_FILES=' $IBUILD_SPEC | awk -F'IBUILD_AUTOUT_FILES=' {'print $2'}`
 export IBUILD_GRTSRV_ID=`grep '^IBUILD_GRTSRV_ID=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_ID=' {'print $2'}`
	[[ -z $IBUILD_GRTSRV_ID ]] && export export IBUILD_GRTSRV_ID=$IBUILD_GRTSRV_ID_DEFAULT
 export IBUILD_GRTSRV=`grep '^IBUILD_GRTSRV=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV=' {'print $2'}`
 export IBUILD_GRTSRV_BRANCH=`grep '^IBUILD_GRTSRV_BRANCH=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_BRANCH=' {'print $2'}`
 export IBUILD_GRTSRV_INIT_OPTION=`grep '^IBUILD_GRTSRV_INIT_OPTION=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_INIT_OPTION=' {'print $2'}`
 export IBUILD_GRTSRV_MANIFEST=`grep '^IBUILD_GRTSRV_MANIFEST=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_MANIFEST=' {'print $2'}`
 export IBUILD_GRTSRV_REPO=`grep '^IBUILD_GRTSRV_REPO=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_REPO=' {'print $2'}`
 export IBUILD_GRTSRV_URL=`grep '^IBUILD_GRTSRV_URL=' $IBUILD_SPEC | awk -F'IBUILD_GRTSRV_URL=' {'print $2'}`
 export IBUILD_MAKE_OPTION=`grep '^IBUILD_MAKE_OPTION=' $IBUILD_SPEC | awk -F'IBUILD_MAKE_OPTION=' {'print $2'}`
 export IBUILD_MAKE_TOOL=`grep '^IBUILD_MAKE_TOOL=' $IBUILD_SPEC | awk -F'IBUILD_MAKE_TOOL=' {'print $2'}`
 export IBUILD_MODE=`grep '^IBUILD_MODE=' $IBUILD_SPEC | awk -F'IBUILD_MODE=' {'print $2'}`
 export IBUILD_UPLOAD_URL=`grep '^IBUILD_UPLOAD_URL=' $IBUILD_SPEC | awk -F'IBUILD_UPLOAD_URL=' {'print $2'}`
 export IBUILD_TARGET_BUILD_VARIANT=`grep '^IBUILD_TARGET_BUILD_VARIANT=' $IBUILD_SPEC | awk -F'IBUILD_TARGET_BUILD_VARIANT=' {'print $2'}`
 export IBUILD_TARGET_PRODUCT=`grep '^IBUILD_TARGET_PRODUCT=' $IBUILD_SPEC | awk -F'IBUILD_TARGET_PRODUCT=' {'print $2'}`
 export IBUILD_REL_REV=`grep '^IBUILD_REL_REV=' $IBUILD_SPEC | awk -F'IBUILD_REL_REV=' {'print $2'}`
 export IBUILD_AOSP_JDK=`grep '^IBUILD_AOSP_JDK=' $IBUILD_SPEC | awk -F'IBUILD_AOSP_JDK=' {'print $2'}`
 export JDK_PATH=`ls -d $JDK6_PATH $JDK7_PATH | grep $IBUILD_AOSP_JDK`
 export IBUILD_PRIORITY=`grep '^IBUILD_PRIORITY=' $IBUILD_SPEC | awk -F'IBUILD_PRIORITY=' {'print $2'}`
 export IVERIFY=$(grep '^IVERIFY=' $IBUILD_SPEC | awk -F'IVERIFY=' {'print $2'})
 export IVERIFY_PRIORITY=$(grep '^IVERIFY_PRIORITY=' $IBUILD_SPEC | awk -F'IVERIFY_PRIORITY=' {'print $2'})
 export ITASK_ORDER=$(grep '^ITASK_ORDER=' $IBUILD_SPEC | awk -F'ITASK_ORDER=' {'print $2'} | head -n1)
     [[ -z $ITASK_ORDER && ! -z $ITASK_TMP ]] && export ITASK_ORDER=$ITASK_TMP
 export IBUILD_REF_REPO=$(grep '^IBUILD_REF_REPO=' $IBUILD_SPEC | awk -F'IBUILD_REF_REPO=' {'print $2'}) 
 export IBUILD_ADD_STEP_1=`grep '^IBUILD_ADD_STEP_1=' $IBUILD_SPEC | awk -F'IBUILD_ADD_STEP_1=' {'print $2'}`
 [[ ! -z $IBUILD_ADD_STEP_1 ]] && export IBUILD_ADD_STEP_1_LOG_NAME=`basename $IBUILD_ADD_STEP_1`
 export IBUILD_ADD_STEP_2=`grep '^IBUILD_ADD_STEP_2=' $IBUILD_SPEC | awk -F'IBUILD_ADD_STEP_2=' {'print $2'}`
 [[ ! -z $IBUILD_ADD_STEP_2 ]] && export IBUILD_ADD_STEP_2_LOG_NAME=`basename $IBUILD_ADD_STEP_2`

 export GERRIT_CHANGE_NUMBER=`grep '^GERRIT_CHANGE_NUMBER=' $IBUILD_SPEC | awk -F'GERRIT_CHANGE_NUMBER=' {'print $2'}`
 export GERRIT_CHANGE_ID=`grep '^GERRIT_CHANGE_ID=' $IBUILD_SPEC | awk -F'GERRIT_CHANGE_ID=' {'print $2'}`
 export GERRIT_CHANGE_URL=`grep '^GERRIT_CHANGE_URL=' $IBUILD_SPEC | awk -F'GERRIT_CHANGE_URL=' {'print $2'}`
 export GERRIT_CHANGE_OWNER_EMAIL=`grep '^GERRIT_CHANGE_OWNER_EMAIL=' $IBUILD_SPEC | awk -F'GERRIT_CHANGE_OWNER_EMAIL=' {'print $2'}`
 export GERRIT_CHANGE_OWNER_NAME=`grep '^GERRIT_CHANGE_OWNER_NAME=' $IBUILD_SPEC | awk -F'GERRIT_CHANGE_OWNER_NAME=' {'print $2'}`
 export GERRIT_PATCHSET_NUMBER=`grep '^GERRIT_PATCHSET_NUMBER=' $IBUILD_SPEC | awk -F'GERRIT_PATCHSET_NUMBER=' {'print $2'}`
 export GERRIT_PATCHSET_REVISION=`grep '^GERRIT_PATCHSET_REVISION=' $IBUILD_SPEC | awk -F'GERRIT_PATCHSET_REVISION=' {'print $2'}`
 export GERRIT_PROJECT=`grep '^GERRIT_PROJECT=' $IBUILD_SPEC | awk -F'GERRIT_PROJECT=' {'print $2'}`
# export =`grep '^=' $IBUILD_SPEC | awk -F'=' {'print $2'}`
 export IBUILD_GRTSRV_BRANCH_TOP=$(echo $IBUILD_GRTSRV_BRANCH | awk -F'/' {'print $1'})
 export KBITS_PROJECT=${IBUILD_TARGET_PRODUCT}$(echo $IBUILD_GRTSRV_BRANCH | awk -F"$IBUILD_GRTSRV_BRANCH_TOP" {'print $2'} | sed 's/\//_/g')

 export SPEC_NAME=`basename $IBUILD_SPEC`
 export AUTOUT_PATH=$LOC_WORKSPACE/autout
 export AUTOUT_UPLOAD_PATH=$LOC_WORKSPACE/upload
 export AUTOUT_NAME=`echo $SPEC_NAME | awk -F'spec.build.' {'print $2'}`
 export LOG_PATH=$AUTOUT_PATH/log
	mkdir -p $AUTOUT_PATH/$AUTOUT_NAME $AUTOUT_UPLOAD_PATH $LOG_PATH >/dev/null 2>&1
	echo '#'$SPEC_NAME >$LOG_PATH/build_info.txt
	cat $TASK_SPACE/spec.build >>$LOG_PATH/build_info.txt
}

FILTER_BAD_PATCH()
{
 export BAD_PATCH_FILTER=$1
 echo $BAD_PATCH_FILTER >>$LOG_PATH/rebundle.log 2>&1
# export BAD_PATCH_PROJECT=$(grep error $LOG_PATH/bundle.log | egrep 'not found' | awk -F' ' {'print $3'})
 export NEW_IBUILD_SPEC_NAME=rebundle.spec.build.$(basename $IBUILD_SPEC | awk -F'spec.build.' {'print $2'})
 export BAD_PATCH_ENTRY=$(grep $BAD_PATCH_FILTER $IBUILD_SPEC | head -n1)
 [[ `echo $BAD_PATCH_ENTRY | grep '|'` ]] && export BAD_PATCH_ENTRY=$BAD_PATCH_FILTER
 cp $IBUILD_SPEC /tmp/$NEW_IBUILD_SPEC_NAME

 echo $BAD_PATCH_ENTRY >>$LOG_PATH/rebundle.log 2>&1
 egrep -v "$BAD_PATCH_ENTRY|^ITASK_ORDER=$" /tmp/$NEW_IBUILD_SPEC_NAME >$TASK_SPACE/tmp.spec.$SEED

 if [[ ! `grep '^ITASK_ORDER=' $TASK_SPACE/tmp.spec.$SEED` ]] ; then
     [[ -z $ITASK_ORDER ]] && export ITASK_ORDER=$ITASK_TMP
     echo "ITASK_ORDER=$ITASK_TMP" >>$TASK_SPACE/tmp.spec.$SEED
 fi
 cp $TASK_SPACE/tmp.spec.$SEED /tmp/$NEW_IBUILD_SPEC_NAME

 rm -f /tmp/itask $TASK_SPACE/tmp.spec.$SEED

 svn export -q $IBUILD_SVN_OPTION svn://$IBUILD_SVN_SRV/ispec/itask /tmp
 chmod +x /tmp/itask

 SPLIT_LINE "add new task after remove $BAD_PATCH_ENTRY"
 /tmp/itask /tmp/$NEW_IBUILD_SPEC_NAME >>$LOG_PATH/rebundle.log 2>&1
}

BUNDLE_BUILD()
{
# BUNDLE_PATCH repo download mode
 grep '^BUNDLE_PATCH=' $IBUILD_SPEC | awk -F'BUNDLE_PATCH=' {'print $2'} | while read BUNDLE_PATCH_ENTRY
 do
     export EMAIL_PATCH_OWNER=$(echo $BUNDLE_PATCH_ENTRY | awk -F'|' {'print $1'})
     export BUNDLE_PATCH=$(echo $BUNDLE_PATCH_ENTRY | awk -F'|' {'print $2'})

     SPLIT_LINE "bundle: repo download $BUNDLE_PATCH"
     echo "------------------------- $EMAIL_PATCH_OWNER|$BUNDLE_PATCH" >>$LOG_PATH/bundle.log 2>&1
     time $REPO_CMD download $BUNDLE_PATCH >>$LOG_PATH/bundle.log 2>&1
     export STATUS_REPO=$?
     [[ $STATUS_REPO != 0 && ! -z $BUNDLE_PATCH ]] && FILTER_BAD_PATCH $BUNDLE_PATCH
     LOG_STATUS $STATUS_REPO bundle $LOG_PATH/bundle.log
 done
# repo download mode
 grep '^repo download' $IBUILD_SPEC | while read BUNDLE_PATCH_ENTRY
 do
     [[ ! -z $EMAIL_TMP ]] && export EMAIL_PATCH_OWNER=$EMAIL_TMP
     export BUNDLE_PATCH=$(echo $BUNDLE_PATCH_ENTRY | awk -F'download' {'print $2'})

     SPLIT_LINE "bundle: repo download $BUNDLE_PATCH"
     echo "------------------------- $EMAIL_PATCH_OWNER|$BUNDLE_PATCH" >>$LOG_PATH/bundle.log 2>&1
     time $REPO_CMD download $BUNDLE_PATCH >>$LOG_PATH/bundle.log 2>&1
     export STATUS_REPO=$?
     [[ $STATUS_REPO != 0 && ! -z $BUNDLE_PATCH ]] && FILTER_BAD_PATCH $BUNDLE_PATCH
     LOG_STATUS $STATUS_REPO bundle $LOG_PATH/bundle.log
 done
# git fetch mode
 grep '^IBUILD_FETCH_HEAD=' $IBUILD_SPEC | grep -v '|$'| awk -F'IBUILD_FETCH_HEAD=' {'print $2'} | while read IBUILD_FETCH_HEAD_ENTRY
 do
    export IBUILD_FETCH_HEAD_PROJECT=$(echo $IBUILD_FETCH_HEAD_ENTRY | awk -F'|' {'print $1'})
    export IBUILD_FETCH_HEAD_REFS=$(echo $IBUILD_FETCH_HEAD_ENTRY | awk -F'|' {'print $2'})
    export IBUILD_FETCH_HEAD_PATH=$($REPO_CMD list | grep $IBUILD_FETCH_HEAD_PROJECT$ | awk -F':' {'print $1'} | head -n1)
    [[ -z $IBUILD_FETCH_HEAD_PATH ]] && export IBUILD_FETCH_HEAD_PATH="NO_path_for_$IBUILD_FETCH_HEAD_PROJECT"
    SPLIT_LINE "bundle: git fetch $IBUILD_FETCH_HEAD_REFS in $IBUILD_FETCH_HEAD_PATH"
    echo "------------------------- $IBUILD_FETCH_HEAD_PROJECT $IBUILD_FETCH_HEAD_REFS" >>$LOG_PATH/bundle.log 2>&1
    echo -e "cd $BUILD_PATH_TOP/$IBUILD_FETCH_HEAD_PATH" >>$LOG_PATH/bundle.log 2>&1
    cd $BUILD_PATH_TOP/$IBUILD_FETCH_HEAD_PATH >>$LOG_PATH/bundle.log 2>&1
    export STATUS_GIT=$?
    echo -e "git fetch ssh://$IBUILD_GRTSRV/$IBUILD_FETCH_HEAD_PROJECT $IBUILD_FETCH_HEAD_REFS\n" >>$LOG_PATH/bundle.log 2>&1
    time git fetch ssh://$IBUILD_GRTSRV_ID@$IBUILD_GRTSRV/$IBUILD_FETCH_HEAD_PROJECT $IBUILD_FETCH_HEAD_REFS >>$LOG_PATH/bundle.log 2>&1
    export STATUS_GIT=$?
    echo $STATUS_GIT >>$LOG_PATH/bundle.log
    if [[ $STATUS_GIT = 0 ]] ; then
        echo -e "\ngit cherry-pick FETCH_HEAD\n" >>$LOG_PATH/bundle.log 2>&1
        git cherry-pick FETCH_HEAD >>$LOG_PATH/bundle.log 2>&1
        export STATUS_GIT=$?
        echo $STATUS_GIT >>$LOG_PATH/bundle.log
    fi
    if [[ $STATUS_GIT != 0 && ! -z $IBUILD_FETCH_HEAD_REFS ]] ; then
        FILTER_BAD_PATCH $IBUILD_FETCH_HEAD_REFS
    fi
    LOG_STATUS $STATUS_GIT bundle $LOG_PATH/bundle.log
 done
 cd $BUILD_PATH_TOP
 EXPORT_MANIFEST $LOG_PATH/after_patch_manifest.xml
}

SPLIT_LINE()
{
 export SPLIT_WORD=''
 [[ ! -z $1 ]] && export SPLIT_WORD=" $1 "
 echo -e "\n-------------------------$SPLIT_WORD"
}

BTRFS_CLEANUP()
{
 export BTRFS_TOP=`basename $1`

 for REF_REPO_MD5 in `ls $LOC_WORKSPACE/ref_repo | egrep -v 'info'`
 do
	if [[ ! -f $LOC_WORKSPACE/ref_repo/$REF_REPO_MD5/Makefile ]] ; then
		export SEED=$RANDOM
		echo -------------------------
		echo $LOC_WORKSPACE/ref_repo/$REF_REPO_MD5
		echo $LOC_WORKSPACE/build/bad.$SEED
		cat $LOC_WORKSPACE/ref_repo/$REF_REPO_MD5.info
		echo -------------------------
		mv $LOC_WORKSPACE/ref_repo/$REF_REPO_MD5 $LOC_WORKSPACE/build/bad.$SEED
		mv $LOC_WORKSPACE/ref_repo/$REF_REPO_MD5.info $LOC_WORKSPACE/build/bad.$SEED/
	fi
 done

 rm -f $LOC_WORKSPACE/build/*.info >/dev/null 2>&1

 for BTRFS_SUBVOL in `ls $LOC_WORKSPACE/build/`
 do
	mv $LOC_WORKSPACE/build/$BTRFS_SUBVOL $LOC_WORKSPACE/build/bad.$SEED.$RANDOM >/dev/null 2>&1
 done

 for BTRFS_SUBVOL in `sudo btrfs subvolume list $LOC_WORKSPACE | egrep -v 'ref_repo' | awk -F'path ' {'print $2'} | grep $BTRFS_TOP | awk -F'build/' {'print $2'}`
 do
	sleep 3
	SPLIT_LINE clean_$LOC_WORKSPACE/$BTRFS_SUBVOL
	rm -f $LOC_WORKSPACE/$BTRFS_SUBVOL.info
	time sudo btrfs subvolume delete $LOC_WORKSPACE/build/$BTRFS_SUBVOL >>$LOG_PATH/fs_issue.log 2>&1
	[[ $? != 0 ]] && echo "fs: "`date` >>$LOCK_SPACE/count
 done

 if [[ `sudo btrfs subvolume list $LOC_WORKSPACE | grep $BTRFS_TOP` ]] ; then
	sudo btrfs subvolume list $LOC_WORKSPACE | grep $BTRFS_TOP >>$LOG_PATH/fs_issue.log 2>&1
	echo "fs_issue: "`date` >>$LOCK_SPACE/count
 fi
}

MASK_LOG()
{
 export MASK_LOG_SRC=$1
 cat $MASK_LOG_SRC | sed "s/$IBUILD_GRTSRV_ID/*/g" >/tmp/tmp.log.$SEED
 mv /tmp/tmp.log.$SEED $MASK_LOG_SRC
}

REPO_INFO()
{
 export IBUILD_GRTSRV_PORT=`echo $IBUILD_GRTSRV | awk -F':' {'print $2'}`
 export IBUILD_GRTSRV_NAME=`echo $IBUILD_GRTSRV | awk -F':' {'print $1'}`
 ssh -p $IBUILD_GRTSRV_PORT $IBUILD_GRTSRV_ID@$IBUILD_GRTSRV_NAME >$LOG_PATH/$IBUILD_GRTSRV_NAME.log 2>&1
 MASK_LOG $LOG_PATH/$IBUILD_GRTSRV_NAME.log
 
 export REPO_INIT_CMD=''
 [[ ! -z $IBUILD_GRTSRV_REPO ]] && export REPO_INIT_CMD=$REPO_INIT_CMD" --repo-url=ssh://$IBUILD_GRTSRV_ID_DEFAULT@$IBUILD_GRTSRV_REPO"
 [[ ! -z $IBUILD_GRTSRV_INIT_OPTION ]] && export REPO_INIT_CMD=$REPO_INIT_CMD" $IBUILD_GRTSRV_INIT_OPTION"
 [[ ! -z $LOC_REPO_MIRROR_PATH ]] && export REPO_INIT_CMD=$REPO_INIT_CMD" --reference=$LOC_REPO_MIRROR_PATH"
 [[ ! -z $IBUILD_GRTSRV_BRANCH ]] && export REPO_INIT_CMD=$REPO_INIT_CMD" -b $IBUILD_GRTSRV_BRANCH"
 [[ ! -z $IBUILD_GRTSRV_MANIFEST && $IBUILD_GRTSRV_MANIFEST != default.xml ]] && export REPO_INIT_CMD=$REPO_INIT_CMD" -m $IBUILD_GRTSRV_MANIFEST"

 echo "$REPO_CMD init -u ssh://$IBUILD_GRTSRV_ID@$IBUILD_GRTSRV/$IBUILD_GRTSRV_URL $REPO_INIT_CMD" >/tmp/$USER.repo_init.tmp
 export REPO_INIT_CMD_MD5_NAME=`cat /tmp/$USER.repo_init.tmp | md5sum | awk -F' ' {'print $1'}`
 export BTRFS_NAME=$REPO_INIT_CMD_MD5_NAME
 export BUILD_PATH_TOP=$LOC_WORKSPACE/build/$BTRFS_NAME
 if [[ ! -z $IBUILD_REF_REPO && -d $LOC_WORKSPACE/ref_repo/$IBUILD_REF_REPO ]] ; then
    export LOC_REF_REPO=$LOC_WORKSPACE/ref_repo/$IBUILD_REF_REPO
 else
    export LOC_REF_REPO=$LOC_WORKSPACE/ref_repo/$REPO_INIT_CMD_MD5_NAME
 fi
    [[ ! -d $LOC_REF_REPO ]] && SETUP_REF_REPO
}

SETUP_REF_REPO()
{
 if [[ ! -d $LOC_WORKSPACE/ref_repo/$REPO_INIT_CMD_MD5_NAME ]] ; then
	mv /tmp/$USER.repo_init.tmp $LOC_WORKSPACE/ref_repo/$REPO_INIT_CMD_MD5_NAME.info
	cd $LOC_WORKSPACE/ref_repo/
	btrfs subvolume create $REPO_INIT_CMD_MD5_NAME >/dev/null 2>&1
	chmod 775 $LOC_WORKSPACE/ref_repo/$REPO_INIT_CMD_MD5_NAME
	cd $LOC_WORKSPACE/ref_repo/$REPO_INIT_CMD_MD5_NAME
	/bin/bash $LOC_WORKSPACE/ref_repo/$REPO_INIT_CMD_MD5_NAME.info >$LOG_PATH/init.log 2>&1
	MASK_LOG $LOG_PATH/init.log
	REPO_SYNC $LOC_WORKSPACE/ref_repo/$REPO_INIT_CMD_MD5_NAME
	cp $LOC_WORKSPACE/ref_repo/$REPO_INIT_CMD_MD5_NAME.info $LOC_WORKSPACE/ref_repo/$REPO_INIT_CMD_MD5_NAME/ >/dev/null 2>&1
 fi
}

IBUILD_ADD_STEP_1()
{
 svn cleanup ~/.m2 >$LOG_PATH/svn_up_m2.log 2>&1
 svn st ~/.m2 >/tmp/svn.st.log
 for CLEAN in `cat /tmp/svn.st.log | grep '^?' | awk -F'^?' {'print $2'}`
 do
	[[ -e $CLEAN ]] && rm -fr $CLEAN
 done
 svn up ~/.m2 >>$LOG_PATH/svn_up_m2.log 2>&1

 SPLIT_LINE "$IBUILD_ADD_STEP_1"
 echo ---------- `date` >>$LOG_PATH/$IBUILD_ADD_STEP_1_LOG_NAME.log 2>&1
 if [[ `echo $IBUILD_ADD_STEP_1 | egrep 'svn.sh'` ]] ; then
	time $IBUILD_ROOT/$IBUILD_ADD_STEP_1 >>$LOG_PATH/$IBUILD_ADD_STEP_1_LOG_NAME.log 2>&1
 else
	TIMEOUT_KILL 200 git &
	time $IBUILD_ADD_STEP_1 -j30 >>$LOG_PATH/$IBUILD_ADD_STEP_1_LOG_NAME.log 2>&1
 fi
 echo ---------- `date` >>$LOG_PATH/$IBUILD_ADD_STEP_1_LOG_NAME.log 2>&1
}

IBUILD_ADD_STEP_2()
{
 SPLIT_LINE "$IBUILD_ADD_STEP_2"
 time $IBUILD_ADD_STEP_2 >$LOG_PATH/$IBUILD_ADD_STEP_2_LOG_NAME.log 2>&1
 LOG_STATUS $? $IBUILD_ADD_STEP_2 $LOG_PATH/$IBUILD_ADD_STEP_2_LOG_NAME.log
}

REPO_SYNC()
{
 cd $1
 export REPO_SYNC_MD5_INFO=$1.info
 export REPO_SYNC_LOG_NAME=sync-`basename $1`
 export INDEX_LOCK=''

 $IBUILD_ROOT/hotfix/clean_dirty.sh

 if [[ ! -f $REPO_SYNC_MD5_INFO ]] ; then
    SPLIT_LINE repo_init_$IBUILD_GRTSRV_MANIFEST
    time $REPO_CMD init -u ssh://$IBUILD_GRTSRV_ID@$IBUILD_GRTSRV/$IBUILD_GRTSRV_URL $REPO_INIT_CMD >>$LOG_PATH/init.log 2>&1
    MASK_LOG $LOG_PATH/init.log
 else
    SPLIT_LINE repo_init
    /bin/bash $REPO_SYNC_MD5_INFO >>$LOG_PATH/init.log 2>&1
    MASK_LOG $LOG_PATH/init.log
 fi

 SPLIT_LINE repo_sync
 time $REPO_CMD sync -j$JOBS >$LOG_PATH/$REPO_SYNC_LOG_NAME.log 2>&1
 export STATUS_SYNC=$?

 for INDEX_LOCK_REPO in `grep index.lock $LOG_PATH/$REPO_SYNC_LOG_NAME.log | awk -F"'" {'print $2'} | awk -F'/.git' {'print $1'}`
 do
    rm -fr $INDEX_LOCK_REPO
    export INDEX_LOCK=true
 done

 if [[ ! -z $INDEX_LOCK ]] ; then
    time $REPO_CMD sync -j$JOBS >$LOG_PATH/$REPO_SYNC_LOG_NAME.log 2>&1
    export STATUS_SYNC=$?
 fi

 EXPORT_MANIFEST $LOG_PATH/after_sync_manifest.xml

 LOG_STATUS $STATUS_SYNC repo_sync $LOG_PATH/$REPO_SYNC_LOG_NAME.log
 CCACHE_HOTFIX

 rm -f out
 if [[ -d /local/out ]]; then
        ln -sf /local/out
 fi
 find >file.list
}

SETUP_BUILD_REPO()
{
 BTRFS_CLEANUP $LOC_WORKSPACE/build

 for BTRFS_OLD_PATH in `ls $LOC_WORKSPACE/build/`
 do
	BTRFS_CLEANUP $LOC_WORKSPACE/build/$BTRFS_OLD_PATH
 done

 SPLIT_LINE snapshot_$BUILD_PATH_TOP 
 time btrfs subvolume snapshot $LOC_REF_REPO $BUILD_PATH_TOP >>$LOG_PATH/fs_issue.log 2>&1
 LOG_STATUS $? snapshot_$BUILD_PATH_TOP $LOG_PATH/fs_issue.log

 REPO_SYNC $BUILD_PATH_TOP
}

CCACHE_HOTFIX()
{
 export NEW_CCACHE_URL=$IBUILD_ROOT/bin/ccache-LDFLAGS-3.2
 export ORIG_CCACHE_URL=prebuilts/misc/linux-x86/ccache/ccache
 export NEW_MD5=`md5sum $NEW_CCACHE_URL | awk -F' ' {'print $1'}`
 export ORIG_MD5=`md5sum $ORIG_CCACHE_URL | awk -F' ' {'print $1'}`

 if [[ -f $ORIG_CCACHE_URL && $NEW_MD5 != $ORIG_MD5 ]] ; then
	/bin/cp $NEW_CCACHE_URL $ORIG_CCACHE_URL >/dev/null 2>&1
 fi
}

SETUP_IVER()
{
 export ORIG_MAINFEST_URL=$1
 export IVER_MAINFEST_NAME=$2.xml

 if [[ -d $TASK_SPACE/iversion-$TOWEEK ]] ; then
	export IBUILD_SVN_REV_LOC=`svn info $TASK_SPACE/iversion-$TOWEEK | grep 'Last Changed Rev: ' | awk -F': ' {'print $2'}`
	if [[ $IBUILD_SVN_REV_SRV != $IBUILD_SVN_REV_LOC ]] ; then
		svn up -q $IBUILD_SVN_OPTION $TASK_SPACE/iversion-$TOWEEK
	fi
else
	rm -fr $TASK_SPACE/iversion-*
	svn mkdir -q $IBUILD_SVN_OPTION -m "auto: add iversion/$TOYEAR/$TOWEEK" svn://$IBUILD_SVN_SRV/iversion/iversion/$TOYEAR/$TOWEEK >/dev/null 2>&1
	svn co -q $IBUILD_SVN_OPTION svn://$IBUILD_SVN_SRV/iversion/iversion/$TOYEAR/$TOWEEK $TASK_SPACE/iversion-$TOWEEK
 fi
 cp $ORIG_MAINFEST_URL $TASK_SPACE/iversion-$TOWEEK/$IVER_MAINFEST_NAME
 SPLIT_LINE $IVER_MAINFEST_NAME
 svn add $TASK_SPACE/iversion-$TOWEEK/$IVER_MAINFEST_NAME >/dev/null 2>&1
 svn ci -q $IBUILD_SVN_OPTION -m "auto: add $IVER_MAINFEST_NAME" $TASK_SPACE/iversion-$TOWEEK/$IVER_MAINFEST_NAME
 if [[ $? = 0 ]] ; then
	export IVER=r`svn info $TASK_SPACE/iversion-$TOWEEK/$IVER_MAINFEST_NAME | grep 'Last Changed Rev: ' | awk -F': ' {'print $2'}`
 else
	SPLIT_LINE iversion_issue
	echo $IVER_MAINFEST_NAME
	export IVER=r$BUILD_TIME$SEED
 fi
}

SETUP_ICASE()
{
 local ICASE_UPLOAD_URL=$1

 if [[ -z $END_SEC_TIME ]] ; then
	export END_TIME=`date +%y%m%d%H%M%S`
	export END_SEC_TIME=`date +%s`
 fi

 [[ -z $RESULT ]] && export RESULT=ISSUE

 echo "RESULT=$RESULT
STATUS_SYNC=$STATUS_SYNC
STATUS_GIT=$STATUS_GIT
STATUS_REPO=$STATUS_REPO
STATUS_MAKE=$STATUS_MAKE
STATUS_MAKE_REL=$STATUS_MAKE_REL
EMAIL_PATCH_OWNER=$EMAIL_PATCH_OWNER
SLAVE_HOST=`hostname`
SLAVE_IP=$IP
START_TIME=$BUILD_TIME
END_TIME=$END_TIME
IVER=$IVER
ITASK_REV=$ITASK_REV
BUILD_TIME=`echo $END_SEC_TIME - $BUILD_SEC_TIME | bc`
REL_PATH=$TODAY/$AUTOUT_NAME
GERRIT_CHANGE_NUMBER=$GERRIT_CHANGE_NUMBER
GERRIT_CHANGE_ID=$GERRIT_CHANGE_ID
GERRIT_CHANGE_URL=$GERRIT_CHANGE_URL
GERRIT_CHANGE_OWNER_EMAIL=$GERRIT_CHANGE_OWNER_EMAIL
GERRIT_CHANGE_OWNER_NAME=$GERRIT_CHANGE_OWNER_NAME
GERRIT_PATCHSET_NUMBER=$GERRIT_PATCHSET_NUMBER
GERRIT_PATCHSET_REVISION=$GERRIT_PATCHSET_REVISION
GERRIT_PROJECT=$GERRIT_PROJECT
DOWNLOAD_URL=http://$IBUILD_SVN_SRV/ibuild/$ICASE_UPLOAD_URL
DOWNLOAD_PKG_NAME=$DOWNLOAD_PKG_NAME
" >>$LOG_PATH/build_info.txt

 if [[ $ITASK_ORDER != $ITASK_TMP ]] ; then
     [[ -z $ITASK_ORDER && ! -z $ITASK_TMP ]] && export ITASK_ORDER=$ITASK_TMP
     echo "ITASK_ORDER=$ITASK_ORDER" >>$LOG_PATH/build_info.txt
 fi
 cat $LOG_PATH/build_info.txt | sort -u | grep -v ^$ >$LOG_PATH/build_info.tmp
 mv $LOG_PATH/build_info.tmp $LOG_PATH/build_info.txt
 
 if [[ -d $TASK_SPACE/icase-$TOWEEK ]] ; then
	export IBUILD_SVN_REV_LOC=`svn info $TASK_SPACE/icase-$TOWEEK | grep 'Last Changed Rev: ' | awk -F': ' {'print $2'}`
	if [[ $IBUILD_SVN_REV_SRV != $IBUILD_SVN_REV_LOC ]] ; then
		svn up -q $IBUILD_SVN_OPTION $TASK_SPACE/icase-$TOWEEK
	fi
else
	rm -fr $TASK_SPACE/icase-*
	svn mkdir -q $IBUILD_SVN_OPTION -m "auto: add icase/$TOYEAR/$TOWEEK" svn://$IBUILD_SVN_SRV/icase/icase/$TOYEAR/$TOWEEK >/dev/null 2>&1
	svn co -q $IBUILD_SVN_OPTION svn://$IBUILD_SVN_SRV/icase/icase/$TOYEAR/$TOWEEK $TASK_SPACE/icase-$TOWEEK
 fi

 if [[ ! -z $ITASK_REV ]] ; then
    export IVEREV=$IVER.$ITASK_REV
 else
    export IVEREV=$IVER
 fi
 cp $LOG_PATH/build_info.txt $TASK_SPACE/icase-$TOWEEK/$IVEREV.build_info.txt
 svn add $TASK_SPACE/icase-$TOWEEK/$IVEREV.build_info.txt >/dev/null 2>&1
 svn ci -q $IBUILD_SVN_OPTION -m "auto: add $IVEREV.build_info.txt" $TASK_SPACE/icase-$TOWEEK/$IVEREV.build_info.txt
 cp $LOG_PATH/build_info.txt $AUTOUT_UPLOAD_PATH/$ICASE_UPLOAD_URL/
}

EXPORT_MANIFEST()
{
 export EXPORT_MANIFEST_URL=$1
 export EXPORT_MANIFEST_PATH=$(dirname $EXPORT_MANIFEST_URL)
 SPLIT_LINE export_manifest
 time $REPO_CMD manifest -r -o tmp_manifest.xml >/dev/null 2>&1
 /bin/cp tmp_manifest.xml $EXPORT_MANIFEST_URL >/dev/null 2>&1
 /bin/cp tmp_manifest.xml $EXPORT_MANIFEST_PATH/manifest.xml >/dev/null 2>&1
}

SETUP_BUILD_OUT()
{
 [[ -d $BUILD_PATH_TOP ]] && cd $BUILD_PATH_TOP
 EXPORT_MANIFEST $LOG_PATH/after_build_manifest.xml

 if [[ $RESULT != FAILED ]] ; then
	if [[ -f images_$IBUILD_TARGET_PRODUCT.txz ]] ; then
		cp images_$IBUILD_TARGET_PRODUCT.txz $AUTOUT_PATH/$AUTOUT_NAME/ 
		export DOWNLOAD_PKG_NAME=images_$IBUILD_TARGET_PRODUCT.txz
	elif [[ `ls out/* | grep 'release-' | head -n1` ]] ; then
		cd out
		export REL_PKG_NAME=`ls | grep 'release-' | head -n1`
		tar cf $REL_PKG_NAME.tar $REL_PKG_NAME
		cp $REL_PKG_NAME.tar $AUTOUT_PATH/$AUTOUT_NAME/
		export DOWNLOAD_PKG_NAME=$REL_PKG_NAME.tar
	else
		SPLIT_LINE no_release_package
	fi
 fi

 SETUP_IVER $LOG_PATH/manifest.xml $BUILD_TIME.$AUTOUT_NAME
 if [[ ! -z $ITASK_REV ]] ; then
    export IVEREV=$IVER.$ITASK_REV
 else
    export IVEREV=$IVER
 fi

 cp -Ra $LOG_PATH $AUTOUT_PATH/$AUTOUT_NAME/
 export SHORT_AUTOUT_NAME=`echo $AUTOUT_NAME | sed 's/g6.default.//g'`
 mv $AUTOUT_PATH/$AUTOUT_NAME $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME

 if [[ ! -f $AUTOUT_UPLOAD_PATH/README ]] ; then
	sshfs -o nonempty $IBUILD_ROBOT@$IBUILD_UPLOAD_URL $AUTOUT_UPLOAD_PATH >$LOG_PATH/sshfs.log 2>&1
	LOG_STATUS $? sshfs_$AUTOUT_UPLOAD_PATH $LOG_PATH/sshfs.log 
 fi

 mkdir -p $AUTOUT_UPLOAD_PATH/$TODAY
 SPLIT_LINE "upload $TODAY $IVEREV.$SHORT_AUTOUT_NAME"
 [[ -z $ITASK_REV ]] && export ITASK_REV=`ls /tmp/*.log | grep -v old | grep build- | awk -F'-' {'print $2'}| awk -F'.log' {'print $1'} | tail -n1`
 cp /tmp/build-$ITASK_REV.log $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME/log/
 cp /tmp/build-$ITASK_REV.log $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME/

 if [[ -f $LOG_PATH/BUILD_ERROR ]] ; then
	cp $LOG_PATH/BUILD_ERROR $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME/
	cp /tmp/build-*.log $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME/
 else
     export RESULT=PASSED
 fi

 time cp -R $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME $AUTOUT_UPLOAD_PATH/$TODAY/
 export STATUS_CP=$?

 SETUP_ICASE $TODAY/$IVEREV.$SHORT_AUTOUT_NAME
 if [[ $STATUS_CP = 0 ]] ; then
	rm -fr $AUTOUT_PATH/$IVEREV.$SHORT_AUTOUT_NAME &
	rm -fr $BUILD_PATH_TOP/out/* >/dev/null 2>&1
 fi
}

BUILD_ERROR()
{
 touch $LOG_PATH/BUILD_ERROR

 export CHECK_LOG=$1
 export CHECK_LOG_NAME=`basename $CHECK_LOG`
 export ERROR_FILTER='cannot |not |No |no |failed|Error |error:|lost|duplicate annotation|unreported|illegal |expected|duplicate attribute|has private access|uses or overrides|expected constructor|undefined reference|duplicate case label|unqualified enumeration|die|incompatible types|incompatible types|already defined|has private access|overrides|illegal start of expression|doesn|This attribute must be localized|unbound prefix|cannot find symbol|ERROR Resource entry|No resource found that matches the given name|Link to hidden class|Parameter of hidden type|too many initializers|Resource is not public|illegal start of expression|make: ***|Stop'

 if [[ `echo $CHECK_LOG | grep full_build` ]] ; then
	if [[ `cat $CHECK_LOG | wc -l` -ge 100 ]] ; then
		cat $CHECK_LOG | grep -v -i warning | uniq >>$LOG_PATH/error.log
	else
		cat $CHECK_LOG >>$LOG_PATH/error.log
	fi
 elif [[ -f $CHECK_LOG ]] ; then
	tail -n 50 $CHECK_LOG
	cp $CHECK_LOG $LOG_PATH/error.log
 else
	echo "$CHECK_LOG does not exist" >>$LOG_PATH/error.log
 fi
 tail -n30 $LOG_PATH/error.log
}

CLEAN_EXIT()
{
 rm -fr $TASK_SPACE/*spec.build*
 rm -f $LOCK_SPACE/itask.lock
 rm -fr $AUTOUT_PATH/r*
 mv /tmp/build-$ITASK_REV.log /tmp/old.build-$ITASK_REV.log
 exit $1
}

LOG_STATUS()
{
 export CHECK_STATUS=$1
 export CHECK_SUBJECT=$2
 export CHECK_LOG=$3
 export CHECK_LOG_NAME=`basename $CHECK_LOG`

 MASK_LOG $CHECK_LOG
 if [[ $CHECK_STATUS != 0 ]] ; then
     SPLIT_LINE "ERROR LOG: $CHECK_SUBJECT"
     BUILD_ERROR $CHECK_LOG
     export RESULT=FAILED
     echo $CHECK_LOG >$LOG_PATH/BUILD_ERROR
     SETUP_BUILD_OUT
     sleep 5 && pkill -9 $IBUILD_MAKE_TOOL >/dev/null 2>&1 &

     SPLIT_LINE "STOP_BUILD $CHECK_LOG_NAME"
     CLEAN_EXIT $CHECK_STATUS
 else
     [[ -z $RESULT ]] && export RESULT=PASSED
 fi
}

REPO_DOWNLOAD()
{
 SPLIT_LINE "repo download $GERRIT_PROJECT $GERRIT_CHANGE_NUMBER/$GERRIT_PATCHSET_NUMBER"
 time $REPO_CMD download $GERRIT_PROJECT $GERRIT_CHANGE_NUMBER/$GERRIT_PATCHSET_NUMBER >>$LOG_PATH/repo_download.log 2>&1
 export STATUS_REPO=$?
 LOG_STATUS $STATUS_REPO repo_download $LOG_PATH/repo_download.log
}

GET_ICHANGE_STRING()
{
 export ICHANGE_STRING=$1
 export STRING_GERRIT_revision=`echo $ICHANGE_STRING | awk -F'|' {'print $1'}`
 export STRING_GERRIT_id=`echo $ICHANGE_STRING | awk -F'|' {'print $2'}`
 export STRING_GERRIT_email=`echo $ICHANGE_STRING | awk -F'|' {'print $3'}`
        [[ -z $STRING_GERRIT_email ]] && export STRING_GERRIT_email=no_mail
 export STRING_GERRIT_PATH=`echo $ICHANGE_STRING | awk -F'|' {'print $4'}`
 export STRING_GERRIT_PROJECT=`echo $ICHANGE_STRING | awk -F'|' {'print $5'}`
 export STRING_GERRIT_change_number=`echo $ICHANGE_STRING | awk -F'|' {'print $6'}`
 export STRING_GERRIT_patchSet_number=`echo $ICHANGE_STRING | awk -F'|' {'print $7'}`
 export STRING_GERRIT_value=`echo $ICHANGE_STRING | awk -F'|' {'print $8'}`
}

TIMEOUT_KILL()
{
 export TIMEOUT_KILL_SLEEP=$1
 export TIMEOUT_KILL_TARGET=$2
 sleep $TIMEOUT_KILL_SLEEP
 pkill -9 $TIMEOUT_KILL_TARGET
}

